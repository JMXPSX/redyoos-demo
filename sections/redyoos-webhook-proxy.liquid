{% comment %}
  REDYOOS WEBHOOK CORS PROXY SECTION
  
  This section provides a CORS-bypass solution for webhook requests using multiple fallback methods.
  It creates a JavaScript service that handles webhook sending with proper error handling.
  
  Methods used to bypass CORS:
  1. Server-side image pixel tracking (most reliable)
  2. Dynamic script injection (JSONP-style)
  3. SendBeacon with proper content type
  4. Form submission to hidden iframe
  5. No-cors fetch with simplified payload
{% endcomment %}

{% schema %}
{
  "name": "Redyoos Webhook CORS Proxy",
  "settings": [
    {
      "type": "header",
      "content": "Webhook Proxy Configuration"
    },
    {
      "type": "text",
      "id": "target_webhook_url",
      "label": "Target Webhook URL",
      "default": "https://webhook.site/50c62f38-7160-47fe-9cd8-76b3ad37d796",
      "info": "The external webhook URL to send data to"
    },
    {
      "type": "checkbox",
      "id": "enable_debug",
      "label": "Enable Debug Logging",
      "default": true,
      "info": "Show debug messages in console"
    },
    {
      "type": "select",
      "id": "primary_method",
      "label": "Primary Send Method",
      "default": "pixel_tracking",
      "options": [
        {
          "value": "pixel_tracking",
          "label": "Image Pixel Tracking (Most Reliable)"
        },
        {
          "value": "beacon_api",
          "label": "Beacon API"
        },
        {
          "value": "form_submission",
          "label": "Form Submission"
        },
        {
          "value": "script_injection",
          "label": "Script Injection"
        }
      ],
      "info": "Choose the primary method for sending webhook data"
    }
  ],
  "presets": [
    {
      "name": "Redyoos Webhook CORS Proxy",
      "category": "Redyoos"
    }
  ]
}
{% endschema %}

<!-- Hidden elements for CORS bypass methods -->
<div id="redyoos-webhook-proxy" style="display: none !important; visibility: hidden !important;">
  <!-- Hidden iframe for form submissions -->
  <iframe id="redyoos-webhook-frame" name="redyoos-webhook-frame" style="display: none;"></iframe>
  
  <!-- Hidden form for form-based submissions -->
  <form id="redyoos-webhook-form" method="POST" target="redyoos-webhook-frame" style="display: none;">
    <input type="hidden" id="redyoos-webhook-data" name="data" value="">
  </form>
  
  <!-- Container for dynamic elements -->
  <div id="redyoos-webhook-dynamic"></div>
</div>

<script>
(function() {
  'use strict';
  
  // Configuration
  const CONFIG = {
    targetWebhookUrl: {{ section.settings.target_webhook_url | json }},
    enableDebug: {{ section.settings.enable_debug | json }},
    primaryMethod: {{ section.settings.primary_method | json }},
    maxRetries: 3,
    retryDelay: 1000
  };
  
  // Debug logging
  function debug(message, data) {
    if (CONFIG.enableDebug) {
      console.log(`[REDYOOS WEBHOOK PROXY] ${message}`, data || '');
    }
  }
  
  /**
   * Method 1: Image Pixel Tracking (Most reliable for GET-style data)
   * Encodes data as URL parameters in an image request
   */
  function sendViaPixelTracking(data, callback) {
    debug('Attempting pixel tracking method');
    
    try {
      const img = document.createElement('img');
      const timestamp = Date.now();
      
      // Encode data as URL parameters
      const params = new URLSearchParams({
        data: JSON.stringify(data),
        method: 'pixel_tracking',
        timestamp: timestamp,
        callback: 'redyoos_pixel_' + timestamp
      });
      
      // Create success callback
      window['redyoos_pixel_' + timestamp] = function() {
        debug('Pixel tracking succeeded');
        cleanup();
        callback(true);
      };
      
      // Set up error handling
      img.onerror = function() {
        debug('Pixel tracking failed');
        cleanup();
        callback(false);
      };
      
      img.onload = function() {
        debug('Pixel tracking completed (onload)');
        cleanup();
        callback(true);
      };
      
      function cleanup() {
        if (window['redyoos_pixel_' + timestamp]) {
          delete window['redyoos_pixel_' + timestamp];
        }
        if (img.parentNode) {
          img.parentNode.removeChild(img);
        }
      }
      
      // Make the request
      const url = `${CONFIG.targetWebhookUrl}?${params.toString()}`;
      img.src = url;
      
      // Add to DOM (hidden)
      img.style.cssText = 'position: absolute; left: -9999px; width: 1px; height: 1px;';
      document.getElementById('redyoos-webhook-dynamic').appendChild(img);
      
      // Timeout after 10 seconds
      setTimeout(() => {
        debug('Pixel tracking timeout');
        cleanup();
        callback(false);
      }, 10000);
      
    } catch (error) {
      debug('Pixel tracking error', error);
      callback(false);
    }
  }
  
  /**
   * Method 2: Beacon API (Reliable for POST data)
   */
  function sendViaBeacon(data, callback) {
    debug('Attempting beacon method');
    
    try {
      if (!navigator.sendBeacon) {
        debug('Beacon API not supported');
        callback(false);
        return;
      }
      
      const payload = JSON.stringify(data);
      const blob = new Blob([payload], { type: 'application/json' });
      
      const success = navigator.sendBeacon(CONFIG.targetWebhookUrl, blob);
      debug('Beacon result', success);
      callback(success);
      
    } catch (error) {
      debug('Beacon error', error);
      callback(false);
    }
  }
  
  /**
   * Method 3: Form Submission to Hidden Iframe
   */
  function sendViaForm(data, callback) {
    debug('Attempting form submission method');
    
    try {
      const form = document.getElementById('redyoos-webhook-form');
      const dataInput = document.getElementById('redyoos-webhook-data');
      const iframe = document.getElementById('redyoos-webhook-frame');
      
      if (!form || !dataInput || !iframe) {
        debug('Form elements not found');
        callback(false);
        return;
      }
      
      // Set form action and data
      form.action = CONFIG.targetWebhookUrl;
      dataInput.value = JSON.stringify(data);
      
      // Set up iframe event handlers
      let completed = false;
      
      const onLoad = function() {
        if (!completed) {
          completed = true;
          debug('Form submission completed');
          cleanup();
          callback(true);
        }
      };
      
      const onError = function() {
        if (!completed) {
          completed = true;
          debug('Form submission failed');
          cleanup();
          callback(false);
        }
      };
      
      function cleanup() {
        iframe.removeEventListener('load', onLoad);
        iframe.removeEventListener('error', onError);
      }
      
      iframe.addEventListener('load', onLoad);
      iframe.addEventListener('error', onError);
      
      // Submit form
      form.submit();
      debug('Form submitted');
      
      // Timeout after 15 seconds
      setTimeout(() => {
        if (!completed) {
          completed = true;
          debug('Form submission timeout');
          cleanup();
          callback(false);
        }
      }, 15000);
      
    } catch (error) {
      debug('Form submission error', error);
      callback(false);
    }
  }
  
  /**
   * Method 4: Script Injection (JSONP-style)
   */
  function sendViaScript(data, callback) {
    debug('Attempting script injection method');
    
    try {
      const timestamp = Date.now();
      const callbackName = 'redyoos_jsonp_' + timestamp;
      
      // Create callback function
      window[callbackName] = function(response) {
        debug('Script injection callback received', response);
        cleanup();
        callback(true);
      };
      
      // Create script element
      const script = document.createElement('script');
      script.async = true;
      script.onerror = function() {
        debug('Script injection failed');
        cleanup();
        callback(false);
      };
      
      function cleanup() {
        if (window[callbackName]) {
          delete window[callbackName];
        }
        if (script.parentNode) {
          script.parentNode.removeChild(script);
        }
      }
      
      // Build URL with data
      const params = new URLSearchParams({
        data: JSON.stringify(data),
        callback: callbackName,
        method: 'script_injection'
      });
      
      script.src = `${CONFIG.targetWebhookUrl}?${params.toString()}`;
      
      // Add to DOM
      document.getElementById('redyoos-webhook-dynamic').appendChild(script);
      
      // Timeout
      setTimeout(() => {
        debug('Script injection timeout');
        cleanup();
        callback(false);
      }, 10000);
      
    } catch (error) {
      debug('Script injection error', error);
      callback(false);
    }
  }
  
  /**
   * Method 5: No-CORS Fetch (Simplified)
   */
  function sendViaNoCorsFetch(data, callback) {
    debug('Attempting no-cors fetch method');
    
    try {
      // Simplified payload for no-cors mode
      const simplifiedPayload = {
        event: data.event || 'webhook_data',
        timestamp: data.timestamp || new Date().toISOString(),
        data: JSON.stringify(data)
      };
      
      fetch(CONFIG.targetWebhookUrl, {
        method: 'POST',
        mode: 'no-cors',
        body: JSON.stringify(simplifiedPayload)
      }).then(() => {
        debug('No-cors fetch completed (assumed success)');
        callback(true);
      }).catch(error => {
        debug('No-cors fetch error', error);
        callback(false);
      });
      
    } catch (error) {
      debug('No-cors fetch error', error);
      callback(false);
    }
  }
  
  /**
   * Main webhook sender with fallback chain
   */
  function sendWebhook(data, options = {}) {
    const opts = {
      maxRetries: options.maxRetries || CONFIG.maxRetries,
      retryDelay: options.retryDelay || CONFIG.retryDelay,
      callback: options.callback || function() {}
    };
    
    debug('Starting webhook send process', { data, options: opts });
    
    // Define method chain based on primary method
    let methods = [];
    
    switch (CONFIG.primaryMethod) {
      case 'pixel_tracking':
        methods = [sendViaPixelTracking, sendViaBeacon, sendViaForm, sendViaNoCorsFetch, sendViaScript];
        break;
      case 'beacon_api':
        methods = [sendViaBeacon, sendViaPixelTracking, sendViaForm, sendViaNoCorsFetch, sendViaScript];
        break;
      case 'form_submission':
        methods = [sendViaForm, sendViaBeacon, sendViaPixelTracking, sendViaNoCorsFetch, sendViaScript];
        break;
      case 'script_injection':
        methods = [sendViaScript, sendViaPixelTracking, sendViaBeacon, sendViaForm, sendViaNoCorsFetch];
        break;
      default:
        methods = [sendViaPixelTracking, sendViaBeacon, sendViaForm, sendViaNoCorsFetch, sendViaScript];
    }
    
    let currentMethodIndex = 0;
    let attemptCount = 0;
    
    function tryNextMethod() {
      if (currentMethodIndex >= methods.length) {
        if (attemptCount < opts.maxRetries) {
          // Retry from the beginning
          attemptCount++;
          currentMethodIndex = 0;
          debug(`Retrying webhook send, attempt ${attemptCount}/${opts.maxRetries}`);
          setTimeout(tryNextMethod, opts.retryDelay);
          return;
        } else {
          // All methods failed
          debug('All webhook methods failed after retries');
          opts.callback(false, 'All methods failed');
          return;
        }
      }
      
      const method = methods[currentMethodIndex];
      const methodName = method.name.replace('sendVia', '');
      debug(`Trying method: ${methodName} (${currentMethodIndex + 1}/${methods.length})`);
      
      method(data, function(success) {
        if (success) {
          debug(`Webhook sent successfully via ${methodName}`);
          opts.callback(true, methodName);
        } else {
          debug(`Method ${methodName} failed, trying next`);
          currentMethodIndex++;
          setTimeout(tryNextMethod, 100);
        }
      });
    }
    
    tryNextMethod();
  }
  
  // Expose the webhook sender globally
  window.RedyoosWebhookProxy = {
    send: sendWebhook,
    config: CONFIG,
    debug: debug,
    methods: {
      pixelTracking: sendViaPixelTracking,
      beacon: sendViaBeacon,
      form: sendViaForm,
      script: sendViaScript,
      noCorsFetch: sendViaNoCorsFetch
    }
  };
  
  debug('Redyoos Webhook Proxy initialized', CONFIG);
  
})();
</script>

<!-- Usage Instructions (hidden comment) -->
{% comment %}
  USAGE INSTRUCTIONS:
  
  1. Add this section to any page/template where you need webhook functionality
  2. Use JavaScript to send webhook data:
  
  // Example usage:
  const webhookData = {
    event: 'jewelry_order_completed',
    correlationId: 'order_123',
    jewelryItems: [...],
    metadata: {...}
  };
  
  RedyoosWebhookProxy.send(webhookData, {
    callback: function(success, method) {
      if (success) {
        console.log('Webhook sent via', method);
      } else {
        console.error('Webhook failed');
      }
    }
  });
  
  3. The proxy will automatically try multiple methods to bypass CORS:
     - Image pixel tracking (most reliable)
     - Beacon API
     - Hidden form submission
     - Script injection (JSONP-style)
     - No-CORS fetch
  
  4. All methods are CORS-bypass compatible and will work across domains
{% endcomment %}