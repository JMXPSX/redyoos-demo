{% comment %}
  REDYOOS ORDER WEBHOOK INTEGRATION
  
  This section handles the double payload approach:
  1. Waits for order completion and extracts checkout_token and cart_token
  2. Enhances jewelryItems in sessionStorage with tokens
  3. Sends enhanced jewelryItems payload to webhook endpoint
  
  Purpose: Track jewelry items data with order tokens after checkout completion
  Integration: Detects order completion and processes tokens
  
  WEBHOOK CONFIGURATION:
  - Endpoint URL: https://webhook.site/50c62f38-7160-47fe-9cd8-76b3ad37d796
  - Method: POST
  - Payload: JSON with jewelryItems data enhanced with checkout/cart tokens
  
  FUNCTIONALITY:
  1. Detects order completion on checkout page
  2. Extracts checkout_token and cart_token from order data
  3. Retrieves jewelryItems from sessionStorage
  4. Enhances jewelryItems with extracted tokens
  5. Sends enhanced payload to webhook endpoint
  6. Clears jewelryItems from sessionStorage
  
  ERROR HANDLING:
  - Graceful fallback if token extraction fails
  - Webhook sending continues with available data
  - Console logging for debugging
{% endcomment %}

{% schema %}
{
  "name": "Redyoos Order Webhook",
  "settings": [
    {
      "type": "header",
      "content": "Webhook Configuration"
    },
    {
      "type": "text",
      "id": "webhook_url",
      "label": "Webhook Endpoint URL",
      "default": "https://webhook.site/50c62f38-7160-47fe-9cd8-76b3ad37d796",
      "info": "URL where jewelryItems data with tokens will be sent after order completion"
    },
    {
      "type": "checkbox",
      "id": "enable_logging",
      "label": "Enable Console Logging",
      "default": true,
      "info": "Enable debugging logs in browser console"
    }
  ],
  "presets": [
    {
      "name": "Redyoos Order Webhook",
      "category": "Redyoos"
    }
  ]
}
{% endschema %}

<!-- REDYOOS ORDER WEBHOOK HANDLER -->
<!-- This section is invisible and only contains JavaScript functionality -->

<script>
document.addEventListener('DOMContentLoaded', function() {
  // =================================================================
  // REDYOOS ORDER WEBHOOK INTEGRATION
  // =================================================================
  
  // Configuration
  const WEBHOOK_URL = {{ section.settings.webhook_url | json }};
  const ENABLE_LOGGING = {{ section.settings.enable_logging | json }};
  
  // Logging utility
  function log(message, data = null) {
    if (ENABLE_LOGGING) {
      if (data) {
        console.log(`[REDYOOS ORDER WEBHOOK] ${message}`, data);
      } else {
        console.log(`[REDYOOS ORDER WEBHOOK] ${message}`);
      }
    }
  }
  
  // =================================================================
  // ORDER COMPLETION & TOKEN EXTRACTION
  // =================================================================
  
  /**
   * Extracts checkout_token and cart_token from Shopify order data
   * @returns {Object} Object containing extracted tokens
   */
  function extractOrderTokens() {
    try {
      let checkoutToken = null;
      let cartToken = null;
      
      // Method 1: Extract from Shopify global objects (if available)
      if (typeof Shopify !== 'undefined') {
        if (Shopify.checkout && Shopify.checkout.token) {
          checkoutToken = Shopify.checkout.token;
          log('Extracted checkout_token from Shopify.checkout', checkoutToken);
        }
        if (Shopify.cart && Shopify.cart.token) {
          cartToken = Shopify.cart.token;
          log('Extracted cart_token from Shopify.cart', cartToken);
        }
      }
      
      // Method 2: Extract from meta tags (common Shopify pattern)
      if (!checkoutToken) {
        const checkoutMeta = document.querySelector('meta[name="shopify-checkout-token"]');
        if (checkoutMeta) {
          checkoutToken = checkoutMeta.getAttribute('content');
          log('Extracted checkout_token from meta tag', checkoutToken);
        }
      }
      
      if (!cartToken) {
        const cartMeta = document.querySelector('meta[name="shopify-cart-token"]');
        if (cartMeta) {
          cartToken = cartMeta.getAttribute('content');
          log('Extracted cart_token from meta tag', cartToken);
        }
      }
      
      // Method 3: Extract from URL parameters (checkout pages often have tokens in URL)
      if (!checkoutToken || !cartToken) {
        const urlParams = new URLSearchParams(window.location.search);
        if (!checkoutToken && urlParams.has('checkout_token')) {
          checkoutToken = urlParams.get('checkout_token');
          log('Extracted checkout_token from URL params', checkoutToken);
        }
        if (!cartToken && urlParams.has('cart_token')) {
          cartToken = urlParams.get('cart_token');
          log('Extracted cart_token from URL params', cartToken);
        }
      }
      
      // Method 4: Extract from page JSON-LD or script tags
      if (!checkoutToken || !cartToken) {
        const scriptTags = document.querySelectorAll('script[type="application/json"]');
        scriptTags.forEach(script => {
          try {
            const data = JSON.parse(script.textContent);
            if (!checkoutToken && data.checkout_token) {
              checkoutToken = data.checkout_token;
              log('Extracted checkout_token from JSON script', checkoutToken);
            }
            if (!cartToken && data.cart_token) {
              cartToken = data.cart_token;
              log('Extracted cart_token from JSON script', cartToken);
            }
          } catch (e) {
            // Ignore parsing errors for non-JSON scripts
          }
        });
      }
      
      return { checkoutToken, cartToken };
    } catch (error) {
      log('Error extracting order tokens', error);
      return { checkoutToken: null, cartToken: null };
    }
  }
  
  /**
   * Enhances jewelryItems in sessionStorage with extracted tokens
   * @param {string} checkoutToken - Extracted checkout token
   * @param {string} cartToken - Extracted cart token
   */
  function enhanceJewelryItemsWithTokens(checkoutToken, cartToken) {
    try {
      const jewelryItemsData = sessionStorage.getItem('jewelryItems');
      
      if (!jewelryItemsData) {
        log('No jewelryItems found in sessionStorage to enhance with tokens');
        return;
      }
      
      const jewelryItems = JSON.parse(jewelryItemsData);
      log('Retrieved jewelryItems for token enhancement', { count: jewelryItems.length });
      
      // Enhance each jewelry item with tokens
      const enhancedItems = jewelryItems.map(item => ({
        ...item,
        checkout_token: checkoutToken,
        cart_token: cartToken,
        token_timestamp: new Date().toISOString()
      }));
      
      // Store enhanced items back to sessionStorage
      sessionStorage.setItem('jewelryItems', JSON.stringify(enhancedItems));
      log('Enhanced jewelryItems with tokens', { 
        checkoutToken, 
        cartToken, 
        enhancedCount: enhancedItems.length 
      });
      
      return enhancedItems;
    } catch (error) {
      log('Error enhancing jewelryItems with tokens', error);
      return null;
    }
  }
  
  /**
   * Sends enhanced jewelryItems with tokens to webhook endpoint
   * @param {Array} jewelryItems - Enhanced jewelry items with tokens
   */
  async function sendEnhancedJewelryItemsToWebhook(jewelryItems) {
    try {
      if (!jewelryItems || jewelryItems.length === 0) {
        log('No jewelryItems to send to webhook');
        return false;
      }

      // Generate correlation data
      const correlationId = sessionStorage.getItem('redyoos_correlation_id') || 
                           'redyoos_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      const sessionId = sessionStorage.getItem('redyoos_session_id') || 
                       'sess_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      
      // Store IDs for potential correlation
      sessionStorage.setItem('redyoos_correlation_id', correlationId);
      sessionStorage.setItem('redyoos_session_id', sessionId);
      
      // Prepare enhanced webhook payload
      const payload = {
        // Correlation identifiers
        correlationId: correlationId,
        sessionId: sessionId,
        orderCompletionTimestamp: new Date().toISOString(),
        
        // Event information
        event: 'jewelry_order_completed_with_tokens',
        source: 'redyoos_shopify_order',
        version: '2.0',
        
        // Enhanced jewelry data with tokens
        jewelryItems: jewelryItems,
        jewelryItemsCount: jewelryItems.length,
        jewelryItemsSummary: jewelryItems.map(item => 
          `${item.jewelry_type || 'jewelry'} ($${item.estimated_value_min || 'N/A'}-$${item.estimated_value_max || 'N/A'})`
        ).join(', '),
        
        // Token information
        tokens: {
          checkout_token: jewelryItems[0]?.checkout_token || null,
          cart_token: jewelryItems[0]?.cart_token || null,
          extraction_timestamp: jewelryItems[0]?.token_timestamp || null
        },
        
        // Order and session metadata
        metadata: {
          // Browser/session data
          userAgent: navigator.userAgent,
          url: window.location.href,
          referrer: document.referrer,
          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
          language: navigator.language,
          viewport: {
            width: window.innerWidth,
            height: window.innerHeight
          },
          
          // Order completion context
          pageType: 'checkout_completion',
          hasTokens: !!(jewelryItems[0]?.checkout_token || jewelryItems[0]?.cart_token)
        }
      };

      log('Sending enhanced payload to webhook', payload);

      // Send using fetch with proper headers
      const response = await fetch(WEBHOOK_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Webhook-Source': 'redyoos-order-completion'
        },
        body: JSON.stringify(payload)
      });
      
      if (response.ok) {
        log('Enhanced webhook sent successfully');
        // Clear jewelryItems from sessionStorage after successful send
        sessionStorage.removeItem('jewelryItems');
        log('Cleared jewelryItems from sessionStorage');
        return true;
      } else {
        log('Webhook response not ok:', response.status, response.statusText);
        // Still clear sessionStorage to prevent repeated attempts
        sessionStorage.removeItem('jewelryItems');
        return false;
      }
      
    } catch (error) {
      log('Error sending enhanced webhook', error);
      // Clear sessionStorage even on error to prevent repeated attempts
      sessionStorage.removeItem('jewelryItems');
      return false;
    }
  }

  // =================================================================
  // ORDER COMPLETION DETECTION
  // =================================================================
  
  /**
   * Intercepts checkout initiation and sets up delayed webhook sending
   */
  function interceptCheckoutInitiation() {
    // Method 1: Intercept checkout button clicks (most reliable)
    const checkoutButton = document.querySelector('#checkout, .btn--checkout, [data-checkout-button], button[name="add"][value*="checkout"]');
    if (checkoutButton) {
      log('Found checkout button, adding interception');
      
      checkoutButton.addEventListener('click', (event) => {
        log('Checkout button clicked - setting up delayed webhook processing');
        
        // Store the current timestamp to track when checkout was initiated
        sessionStorage.setItem('redyoos_checkout_initiated', Date.now().toString());
        
        // Set up multiple delayed webhook attempts
        setTimeout(() => processOrderCompletionWebhook(), 3000);  // 3 seconds
        setTimeout(() => processOrderCompletionWebhook(), 7000);  // 7 seconds  
        setTimeout(() => processOrderCompletionWebhook(), 12000); // 12 seconds
        setTimeout(() => processOrderCompletionWebhook(), 20000); // 20 seconds
        
      }, true);
    }
    
    // Method 2: Intercept form submissions to /checkout
    const forms = document.querySelectorAll('form');
    forms.forEach(form => {
      if (form.action.includes('/checkout') || form.action.includes('/cart')) {
        log('Found checkout form, adding interception');
        
        form.addEventListener('submit', (event) => {
          log('Checkout form submitted - setting up delayed webhook processing');
          
          sessionStorage.setItem('redyoos_checkout_initiated', Date.now().toString());
          
          // Multiple delayed attempts
          setTimeout(() => processOrderCompletionWebhook(), 3000);
          setTimeout(() => processOrderCompletionWebhook(), 8000);
          setTimeout(() => processOrderCompletionWebhook(), 15000);
          setTimeout(() => processOrderCompletionWebhook(), 25000);
        });
      }
    });
    
    // Method 3: Watch for any button clicks that might trigger checkout
    document.addEventListener('click', (event) => {
      const target = event.target;
      if (target && (
        target.textContent?.toLowerCase().includes('checkout') ||
        target.textContent?.toLowerCase().includes('complete order') ||
        target.textContent?.toLowerCase().includes('place order') ||
        target.className?.includes('checkout') ||
        target.getAttribute('data-testid')?.includes('checkout')
      )) {
        log('Detected checkout-related button click', target);
        
        sessionStorage.setItem('redyoos_checkout_initiated', Date.now().toString());
        
        // Staggered webhook attempts
        setTimeout(() => processOrderCompletionWebhook(), 2000);
        setTimeout(() => processOrderCompletionWebhook(), 6000);
        setTimeout(() => processOrderCompletionWebhook(), 12000);
      }
    }, true);
  }
  
  /**
   * Detects order completion using multiple strategies
   */
  function detectOrderCompletion() {
    // First, set up checkout interception
    interceptCheckoutInitiation();
    
    // Method 1: Check if we're already on a completion page
    const isCompletionPage = window.location.pathname.includes('/thank_you') || 
                             window.location.pathname.includes('/orders') ||
                             window.location.search.includes('order_id') ||
                             document.querySelector('.os-order-number') ||
                             document.querySelector('.order-confirmation') ||
                             document.querySelector('[data-order-id]') ||
                             document.querySelector('.checkout-complete');
    
    if (isCompletionPage) {
      log('Already on order completion page, processing immediately');
      processOrderCompletionWebhook();
      
      // Also try with delays in case tokens aren't immediately available
      setTimeout(() => processOrderCompletionWebhook(), 2000);
      setTimeout(() => processOrderCompletionWebhook(), 5000);
      return;
    }
    
    // Method 2: Monitor for Shopify checkout state changes
    if (typeof Shopify !== 'undefined') {
      if (Shopify.checkout) {
        let lastStep = Shopify.checkout.step;
        const stepMonitor = setInterval(() => {
          if (Shopify.checkout.step !== lastStep) {
            log('Checkout step changed:', lastStep, '->', Shopify.checkout.step);
            if (Shopify.checkout.step === 'complete' || Shopify.checkout.step === 'processing') {
              processOrderCompletionWebhook();
              clearInterval(stepMonitor);
            }
            lastStep = Shopify.checkout.step;
          }
        }, 1000);
        
        setTimeout(() => clearInterval(stepMonitor), 300000); // 5 minutes max
      }
      
      // Monitor cart token changes
      if (Shopify.cart) {
        let lastCartToken = Shopify.cart.token;
        const cartMonitor = setInterval(() => {
          if (Shopify.cart.token !== lastCartToken) {
            log('Cart token changed, processing webhook');
            processOrderCompletionWebhook();
            lastCartToken = Shopify.cart.token;
          }
        }, 2000);
        
        setTimeout(() => clearInterval(cartMonitor), 300000);
      }
    }
    
    // Method 3: URL change monitoring (for SPA-style checkouts)
    let lastUrl = window.location.href;
    const urlMonitor = setInterval(() => {
      if (window.location.href !== lastUrl) {
        log('URL changed from', lastUrl, 'to', window.location.href);
        
        // Process webhook if moving to completion-related URLs
        if (window.location.href.includes('/thank_you') || 
            window.location.href.includes('/orders') ||
            window.location.search.includes('order_id')) {
          processOrderCompletionWebhook();
          setTimeout(() => processOrderCompletionWebhook(), 3000);
        }
        
        lastUrl = window.location.href;
      }
    }, 1000);
    
    setTimeout(() => clearInterval(urlMonitor), 300000);
    
    // Method 4: Periodic check if checkout was initiated
    const periodicCheck = setInterval(() => {
      const checkoutInitiated = sessionStorage.getItem('redyoos_checkout_initiated');
      const jewelryItems = sessionStorage.getItem('jewelryItems');
      
      if (checkoutInitiated && jewelryItems) {
        const initiatedTime = parseInt(checkoutInitiated);
        const timeSinceInitiated = Date.now() - initiatedTime;
        
        // If checkout was initiated more than 5 seconds ago, try webhook
        if (timeSinceInitiated > 5000) {
          log('Periodic check: checkout initiated', timeSinceInitiated / 1000, 'seconds ago');
          processOrderCompletionWebhook();
        }
        
        // Stop checking after 5 minutes
        if (timeSinceInitiated > 300000) {
          sessionStorage.removeItem('redyoos_checkout_initiated');
        }
      }
    }, 5000);
    
    setTimeout(() => clearInterval(periodicCheck), 300000);
    
    // Method 5: Storage event listener (for cross-tab scenarios)
    window.addEventListener('storage', (event) => {
      if (event.key === 'redyoos_checkout_initiated' && event.newValue) {
        log('Checkout initiated in another tab/window');
        setTimeout(() => processOrderCompletionWebhook(), 2000);
      }
    });
    
    // Method 6: Before page unload (last resort)
    window.addEventListener('beforeunload', () => {
      const jewelryItems = sessionStorage.getItem('jewelryItems');
      const checkoutInitiated = sessionStorage.getItem('redyoos_checkout_initiated');
      
      if (jewelryItems && checkoutInitiated) {
        log('Page unloading with pending jewelry items, attempting immediate webhook');
        // Use synchronous beacon for page unload
        processOrderCompletionWebhook(true); // Pass flag for beacon-only mode
      }
    });
  }
  
  /**
   * Main function that orchestrates the order completion webhook process
   * @param {boolean} beaconOnly - Use only beacon method for immediate sending (page unload)
   */
  async function processOrderCompletionWebhook(beaconOnly = false) {
    try {
      log('Starting order completion webhook process', { beaconOnly });
      
      // Check if we have jewelryItems to process
      const jewelryItemsData = sessionStorage.getItem('jewelryItems');
      if (!jewelryItemsData) {
        log('No jewelryItems found in sessionStorage - skipping webhook process');
        return;
      }
      
      // Check if we've already processed this recently (prevent duplicate sends)
      const lastProcessed = sessionStorage.getItem('redyoos_last_webhook_sent');
      if (lastProcessed) {
        const timeSinceLastSend = Date.now() - parseInt(lastProcessed);
        if (timeSinceLastSend < 30000) { // 30 seconds cooldown
          log('Webhook sent recently, skipping to prevent duplicates', timeSinceLastSend / 1000, 'seconds ago');
          return;
        }
      }
      
      let jewelryItems;
      try {
        jewelryItems = JSON.parse(jewelryItemsData);
      } catch (error) {
        log('Error parsing jewelryItems data', error);
        return;
      }
      
      // Extract tokens from the order/checkout data
      const { checkoutToken, cartToken } = extractOrderTokens();
      
      // Always try to enhance items, even without tokens
      const enhancedItems = jewelryItems.map(item => ({
        ...item,
        checkout_token: checkoutToken || null,
        cart_token: cartToken || null,
        token_timestamp: new Date().toISOString(),
        webhook_attempt: Date.now()
      }));
      
      log('Enhanced jewelryItems', { 
        itemCount: enhancedItems.length,
        hasCheckoutToken: !!checkoutToken,
        hasCartToken: !!cartToken 
      });
      
      // Prepare the webhook payload
      const correlationId = sessionStorage.getItem('redyoos_correlation_id') || 
                           'redyoos_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      const sessionId = sessionStorage.getItem('redyoos_session_id') || 
                       'sess_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      
      sessionStorage.setItem('redyoos_correlation_id', correlationId);
      sessionStorage.setItem('redyoos_session_id', sessionId);
      
      const payload = {
        correlationId: correlationId,
        sessionId: sessionId,
        orderCompletionTimestamp: new Date().toISOString(),
        event: 'jewelry_order_completed_with_tokens',
        source: 'redyoos_shopify_order',
        version: '2.0',
        jewelryItems: enhancedItems,
        jewelryItemsCount: enhancedItems.length,
        jewelryItemsSummary: enhancedItems.map(item => 
          `${item.jewelry_type || 'jewelry'} ($${item.estimated_value_min || 'N/A'}-$${item.estimated_value_max || 'N/A'})`
        ).join(', '),
        tokens: {
          checkout_token: checkoutToken,
          cart_token: cartToken,
          extraction_timestamp: new Date().toISOString()
        },
        metadata: {
          userAgent: navigator.userAgent,
          url: window.location.href,
          referrer: document.referrer,
          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
          language: navigator.language,
          viewport: { width: window.innerWidth, height: window.innerHeight },
          pageType: 'checkout_completion',
          hasTokens: !!(checkoutToken || cartToken),
          beaconOnly: beaconOnly,
          checkoutInitiated: sessionStorage.getItem('redyoos_checkout_initiated')
        }
      };
      
      log('Sending enhanced payload to webhook', payload);
      
      let success = false;
      
      if (beaconOnly) {
        // Use beacon for immediate sending during page unload
        success = navigator.sendBeacon(WEBHOOK_URL, JSON.stringify(payload));
        log('Beacon send result:', success);
      } else {
        // Try multiple sending methods
        try {
          // Method 1: Regular fetch
          const response = await fetch(WEBHOOK_URL, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-Webhook-Source': 'redyoos-order-completion'
            },
            body: JSON.stringify(payload)
          });
          
          if (response.ok) {
            success = true;
            log('Webhook sent successfully via fetch');
          } else {
            log('Fetch response not ok:', response.status, response.statusText);
          }
        } catch (fetchError) {
          log('Fetch failed, trying beacon fallback', fetchError);
          
          // Method 2: Beacon fallback
          success = navigator.sendBeacon(WEBHOOK_URL, JSON.stringify(payload));
          log('Beacon fallback result:', success);
        }
      }
      
      if (success) {
        // Mark as successfully sent
        sessionStorage.setItem('redyoos_last_webhook_sent', Date.now().toString());
        
        // Clear jewelryItems from sessionStorage after successful send
        sessionStorage.removeItem('jewelryItems');
        sessionStorage.removeItem('redyoos_checkout_initiated');
        log('Cleared jewelryItems and checkout flags from sessionStorage');
      }
      
      log('Order completion webhook process completed', { success });
      return success;
      
    } catch (error) {
      log('Error in order completion webhook process', error);
      return false;
    }
  }
  
  // =================================================================
  // INITIALIZATION
  // =================================================================
  
  // Initialize order completion detection
  function initializeOrderCompletionWebhook() {
    log('Initializing Redyoos Order Webhook');
    
    // Start detecting order completion
    detectOrderCompletion();
    
    // Also check immediately if we're already on a completion page
    setTimeout(() => {
      const isCompletionPage = window.location.pathname.includes('/thank_you') || 
                              window.location.pathname.includes('/orders') ||
                              document.querySelector('.os-order-number') ||
                              document.querySelector('.order-confirmation');
      
      if (isCompletionPage) {
        log('Already on order completion page, processing immediately');
        processOrderCompletionWebhook();
      }
    }, 500);
    
    log('Redyoos Order Webhook initialized');
  }
  
  // Wait for DOM to be fully loaded, then initialize
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeOrderCompletionWebhook);
  } else {
    initializeOrderCompletionWebhook();
  }
  
  // Also initialize after a short delay for dynamic content
  setTimeout(initializeOrderCompletionWebhook, 1000);
});
</script>

<!-- 
  INTEGRATION INSTRUCTIONS:
  
  To activate this order completion webhook integration:
  
  1. Add this section to checkout/order completion pages:
     - Go to Shopify Admin > Online Store > Themes
     - Edit the active theme
     - Add to checkout.liquid or thank_you.liquid templates
     - Or add "redyoos-checkout-webhook" to relevant sections
     
  2. Or add via theme customizer:
     - Go to checkout pages in theme customizer
     - Add section > Redyoos Order Webhook
     - Configure webhook URL if needed
     
  3. The section will automatically:
     - Detect order completion using multiple methods
     - Extract checkout_token and cart_token from order data
     - Enhance jewelryItems in sessionStorage with tokens
     - Send enhanced payload to webhook endpoint
     - Clear sessionStorage after successful send
     
  4. Double Payload Flow:
     - First: Shopify's orders/create webhook fires (handled by redyoos-order-attributes.liquid)
     - Second: This enhanced jewelryItems webhook fires with tokens
     
  TROUBLESHOOTING:
  - Check browser console for "[REDYOOS ORDER WEBHOOK]" logs
  - Verify jewelryItems exists in sessionStorage
  - Test webhook endpoint URL separately
  - Ensure proper page detection on order completion
  - Check that order tokens are being extracted successfully
-->