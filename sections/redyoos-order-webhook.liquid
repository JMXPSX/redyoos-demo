{% comment %}
  REDYOOS ORDER WEBHOOK INTEGRATION
  
  This section handles the double payload approach:
  1. Waits for order completion and extracts checkout_token and cart_token
  2. Enhances jewelryItems in sessionStorage with tokens
  3. Sends enhanced jewelryItems payload to webhook endpoint
  
  Purpose: Track jewelry items data with order tokens after checkout completion
  Integration: Detects order completion and processes tokens
  
  WEBHOOK CONFIGURATION:
  - Endpoint URL: https://webhook.site/50c62f38-7160-47fe-9cd8-76b3ad37d796
  - Method: POST
  - Payload: JSON with jewelryItems data enhanced with checkout/cart tokens
  
  FUNCTIONALITY:
  1. Detects order completion on checkout page
  2. Extracts checkout_token and cart_token from order data
  3. Retrieves jewelryItems from sessionStorage
  4. Enhances jewelryItems with extracted tokens
  5. Sends enhanced payload to webhook endpoint
  6. Clears jewelryItems from sessionStorage
  
  ERROR HANDLING:
  - Graceful fallback if token extraction fails
  - Webhook sending continues with available data
  - Console logging for debugging
{% endcomment %}

{% schema %}
{
  "name": "Redyoos Order Webhook",
  "settings": [
    {
      "type": "header",
      "content": "Webhook Configuration"
    },
    {
      "type": "text",
      "id": "webhook_url",
      "label": "Webhook Endpoint URL",
      "default": "https://webhook.site/50c62f38-7160-47fe-9cd8-76b3ad37d796",
      "info": "URL where jewelryItems data with tokens will be sent after order completion"
    },
    {
      "type": "checkbox",
      "id": "enable_logging",
      "label": "Enable Console Logging",
      "default": true,
      "info": "Enable debugging logs in browser console"
    }
  ],
  "presets": [
    {
      "name": "Redyoos Order Webhook",
      "category": "Redyoos"
    }
  ]
}
{% endschema %}

<!-- REDYOOS ORDER WEBHOOK HANDLER -->
<!-- This section is invisible and only contains JavaScript functionality -->

<!-- Inject Shopify cart data directly from Liquid -->
<script id="shopify-cart-data" type="application/json">
{
  "cart_token": {{ cart.token | json }},
  "cart_id": {{ cart.id | json }},
  "cart_item_count": {{ cart.item_count | json }},
  "cart_total_price": {{ cart.total_price | json }}
}
</script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // =================================================================
  // REDYOOS ORDER WEBHOOK INTEGRATION
  // =================================================================
  
  // Configuration
  const WEBHOOK_URL = {{ section.settings.webhook_url | json }};
  const ENABLE_LOGGING = {{ section.settings.enable_logging | json }};
  
  // Logging utility
  function log(message, data = null) {
    if (ENABLE_LOGGING) {
      if (data) {
        console.log(`[REDYOOS ORDER WEBHOOK] ${message}`, data);
      } else {
        console.log(`[REDYOOS ORDER WEBHOOK] ${message}`);
      }
    }
  }
  
  // =================================================================
  // ORDER COMPLETION & TOKEN EXTRACTION
  // =================================================================
  
  /**
   * Extracts checkout_token and cart_token from Shopify order data
   * @returns {Object} Object containing extracted tokens
   */
  function extractOrderTokens() {
    try {
      let checkoutToken = null;
      let cartToken = null;
      
      // Method 1: Extract from Shopify global objects (if available)
      if (typeof Shopify !== 'undefined') {
        if (Shopify.checkout && Shopify.checkout.token) {
          checkoutToken = Shopify.checkout.token;
          log('Extracted checkout_token from Shopify.checkout', checkoutToken);
        }
        if (Shopify.cart && Shopify.cart.token) {
          cartToken = Shopify.cart.token;
          log('Extracted cart_token from Shopify.cart', cartToken);
        }
      }
      
      // Method 2: Extract from localStorage (most common location for cart token)
      if (!cartToken && localStorage.getItem('cartToken')) {
        cartToken = localStorage.getItem('cartToken');
        log('Extracted cart_token from localStorage.cartToken', cartToken);
      }
      
      if (!cartToken && localStorage.getItem('cart_token')) {
        cartToken = localStorage.getItem('cart_token');
        log('Extracted cart_token from localStorage.cart_token', cartToken);
      }
      
      // Method 3: Extract from meta tags (common Shopify pattern)
      if (!checkoutToken) {
        const checkoutMeta = document.querySelector('meta[name="shopify-checkout-token"]');
        if (checkoutMeta) {
          checkoutToken = checkoutMeta.getAttribute('content');
          log('Extracted checkout_token from meta tag', checkoutToken);
        }
      }
      
      if (!cartToken) {
        const cartMeta = document.querySelector('meta[name="shopify-cart-token"]');
        if (cartMeta) {
          cartToken = cartMeta.getAttribute('content');
          log('Extracted cart_token from meta tag', cartToken);
        }
      }
      
      // Method 4: Extract from URL parameters (checkout pages often have tokens in URL)
      if (!checkoutToken || !cartToken) {
        const urlParams = new URLSearchParams(window.location.search);
        if (!checkoutToken && urlParams.has('checkout_token')) {
          checkoutToken = urlParams.get('checkout_token');
          log('Extracted checkout_token from URL params', checkoutToken);
        }
        if (!cartToken && urlParams.has('cart_token')) {
          cartToken = urlParams.get('cart_token');
          log('Extracted cart_token from URL params', cartToken);
        }
      }
      
      // Method 5: Extract from page JSON-LD or script tags
      if (!checkoutToken || !cartToken) {
        const scriptTags = document.querySelectorAll('script[type="application/json"]');
        scriptTags.forEach(script => {
          try {
            const data = JSON.parse(script.textContent);
            if (!checkoutToken && data.checkout_token) {
              checkoutToken = data.checkout_token;
              log('Extracted checkout_token from JSON script', checkoutToken);
            }
            if (!cartToken && data.cart_token) {
              cartToken = data.cart_token;
              log('Extracted cart_token from JSON script', cartToken);
            }
          } catch (e) {
            // Ignore parsing errors for non-JSON scripts
          }
        });
      }
      
      return { checkoutToken, cartToken };
    } catch (error) {
      log('Error extracting order tokens', error);
      return { checkoutToken: null, cartToken: null };
    }
  }
  
  /**
   * Enhances jewelryItems in sessionStorage with extracted tokens
   * @param {string} checkoutToken - Extracted checkout token
   * @param {string} cartToken - Extracted cart token
   */
  function enhanceJewelryItemsWithTokens(checkoutToken, cartToken) {
    try {
      const jewelryItemsData = sessionStorage.getItem('jewelryItems');
      
      if (!jewelryItemsData) {
        log('No jewelryItems found in sessionStorage to enhance with tokens');
        return;
      }
      
      const jewelryItems = JSON.parse(jewelryItemsData);
      log('Retrieved jewelryItems for token enhancement', { count: jewelryItems.length });
      
      // Enhance each jewelry item with tokens
      const enhancedItems = jewelryItems.map(item => ({
        ...item,
        checkout_token: checkoutToken,
        cart_token: cartToken,
        token_timestamp: new Date().toISOString()
      }));
      
      // Store enhanced items back to sessionStorage
      sessionStorage.setItem('jewelryItems', JSON.stringify(enhancedItems));
      log('Enhanced jewelryItems with tokens', { 
        checkoutToken, 
        cartToken, 
        enhancedCount: enhancedItems.length 
      });
      
      return enhancedItems;
    } catch (error) {
      log('Error enhancing jewelryItems with tokens', error);
      return null;
    }
  }
  
  /**
   * Sends enhanced jewelryItems with tokens to webhook endpoint
   * @param {Array} jewelryItems - Enhanced jewelry items with tokens
   */
  async function sendEnhancedJewelryItemsToWebhook(jewelryItems) {
    try {
      if (!jewelryItems || jewelryItems.length === 0) {
        log('No jewelryItems to send to webhook');
        return false;
      }

      // Generate correlation data
      const correlationId = sessionStorage.getItem('redyoos_correlation_id') || 
                           'redyoos_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      const sessionId = sessionStorage.getItem('redyoos_session_id') || 
                       'sess_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      
      // Store IDs for potential correlation
      sessionStorage.setItem('redyoos_correlation_id', correlationId);
      sessionStorage.setItem('redyoos_session_id', sessionId);
      
      // Prepare enhanced webhook payload
      const payload = {
        // Correlation identifiers
        correlationId: correlationId,
        sessionId: sessionId,
        orderCompletionTimestamp: new Date().toISOString(),
        
        // Event information
        event: 'jewelry_order_completed_with_tokens',
        source: 'redyoos_shopify_order',
        version: '2.0',
        
        // Enhanced jewelry data with tokens
        jewelryItems: jewelryItems,
        jewelryItemsCount: jewelryItems.length,
        jewelryItemsSummary: jewelryItems.map(item => 
          `${item.jewelry_type || 'jewelry'} ($${item.estimated_value_min || 'N/A'}-$${item.estimated_value_max || 'N/A'})`
        ).join(', '),
        
        // Token information
        tokens: {
          checkout_token: jewelryItems[0]?.checkout_token || null,
          cart_token: jewelryItems[0]?.cart_token || null,
          extraction_timestamp: jewelryItems[0]?.token_timestamp || null
        },
        
        // Order and session metadata
        metadata: {
          // Browser/session data
          userAgent: navigator.userAgent,
          url: window.location.href,
          referrer: document.referrer,
          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
          language: navigator.language,
          viewport: {
            width: window.innerWidth,
            height: window.innerHeight
          },
          
          // Order completion context
          pageType: 'checkout_completion',
          hasTokens: !!(jewelryItems[0]?.checkout_token || jewelryItems[0]?.cart_token)
        }
      };

      log('Sending enhanced payload to webhook', payload);

      // Send using fetch with proper headers
      const response = await fetch(WEBHOOK_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Webhook-Source': 'redyoos-order-completion'
        },
        body: JSON.stringify(payload)
      });
      
      if (response.ok) {
        log('Enhanced webhook sent successfully');
        // Clear jewelryItems from sessionStorage after successful send
        sessionStorage.removeItem('jewelryItems');
        log('Cleared jewelryItems from sessionStorage');
        return true;
      } else {
        log('Webhook response not ok:', response.status, response.statusText);
        // Still clear sessionStorage to prevent repeated attempts
        sessionStorage.removeItem('jewelryItems');
        return false;
      }
      
    } catch (error) {
      log('Error sending enhanced webhook', error);
      // Clear sessionStorage even on error to prevent repeated attempts
      sessionStorage.removeItem('jewelryItems');
      return false;
    }
  }

  // =================================================================
  // ORDER COMPLETION DETECTION
  // =================================================================
  
  /**
   * Intercepts checkout initiation and sets up delayed webhook sending
   */
  function interceptCheckoutInitiation() {
    // Method 1: Intercept checkout button clicks (most reliable)
    const checkoutButton = document.querySelector('#checkout, .btn--checkout, [data-checkout-button], button[name="add"][value*="checkout"]');
    if (checkoutButton) {
      log('Found checkout button, adding interception');
      
      checkoutButton.addEventListener('click', async (event) => {
        log('Checkout button clicked - setting up delayed webhook processing and checkout token capture');
        
        // Store the current timestamp to track when checkout was initiated
        sessionStorage.setItem('redyoos_checkout_initiated', Date.now().toString());
        
        // Try to capture checkout token from the redirection process
        setTimeout(async () => {
          const checkoutToken = await captureCheckoutTokenFromProcess();
          if (checkoutToken) {
            await attachCheckoutTokenToJewelryItems(checkoutToken);
          }
        }, 1500); // Give more time for redirect to occur
        
        // Set up multiple delayed webhook attempts
        setTimeout(() => processOrderCompletionWebhook(), 3000);  // 3 seconds
        setTimeout(() => processOrderCompletionWebhook(), 7000);  // 7 seconds  
        setTimeout(() => processOrderCompletionWebhook(), 12000); // 12 seconds
        setTimeout(() => processOrderCompletionWebhook(), 20000); // 20 seconds
        
      }, true);
    }
    
    // Method 2: Intercept form submissions to /checkout
    const forms = document.querySelectorAll('form');
    forms.forEach(form => {
      if (form.action.includes('/checkout') || form.action.includes('/cart')) {
        log('Found checkout form, adding interception');
        
        form.addEventListener('submit', async (event) => {
          log('Checkout form submitted - setting up delayed webhook processing and checkout token capture');
          
          sessionStorage.setItem('redyoos_checkout_initiated', Date.now().toString());
          
          // Try to capture checkout token after form submission
          setTimeout(async () => {
            const checkoutToken = await captureCheckoutTokenFromProcess();
            if (checkoutToken) {
              await attachCheckoutTokenToJewelryItems(checkoutToken);
            }
          }, 2000); // Give more time for redirect processing
          
          // Multiple delayed attempts
          setTimeout(() => processOrderCompletionWebhook(), 3000);
          setTimeout(() => processOrderCompletionWebhook(), 8000);
          setTimeout(() => processOrderCompletionWebhook(), 15000);
          setTimeout(() => processOrderCompletionWebhook(), 25000);
        });
      }
    });
    
    // Method 3: Watch for any button clicks that might trigger checkout
    document.addEventListener('click', async (event) => {
      const target = event.target;
      if (target && (
        target.textContent?.toLowerCase().includes('checkout') ||
        target.textContent?.toLowerCase().includes('complete order') ||
        target.textContent?.toLowerCase().includes('place order') ||
        target.className?.includes('checkout') ||
        target.getAttribute('data-testid')?.includes('checkout')
      )) {
        log('Detected checkout-related button click', target);
        
        sessionStorage.setItem('redyoos_checkout_initiated', Date.now().toString());
        
        // Try to capture checkout token after button click
        setTimeout(async () => {
          const checkoutToken = await captureCheckoutTokenFromProcess();
          if (checkoutToken) {
            await attachCheckoutTokenToJewelryItems(checkoutToken);
          }
        }, 1500);
        
        // Staggered webhook attempts
        setTimeout(() => processOrderCompletionWebhook(), 2000);
        setTimeout(() => processOrderCompletionWebhook(), 6000);
        setTimeout(() => processOrderCompletionWebhook(), 12000);
      }
    }, true);
  }
  
  /**
   * Detects order completion using multiple strategies
   */
  function detectOrderCompletion() {
    // First, set up checkout interception
    interceptCheckoutInitiation();
    
    // Method 1: Check if we're already on a completion page
    const isCompletionPage = window.location.pathname.includes('/thank_you') || 
                             window.location.pathname.includes('/orders') ||
                             window.location.search.includes('order_id') ||
                             document.querySelector('.os-order-number') ||
                             document.querySelector('.order-confirmation') ||
                             document.querySelector('[data-order-id]') ||
                             document.querySelector('.checkout-complete');
    
    if (isCompletionPage) {
      log('Already on order completion page, processing immediately');
      processOrderCompletionWebhook();
      
      // Also try with delays in case tokens aren't immediately available
      setTimeout(() => processOrderCompletionWebhook(), 2000);
      setTimeout(() => processOrderCompletionWebhook(), 5000);
      return;
    }
    
    // Method 2: Monitor for Shopify checkout state changes
    if (typeof Shopify !== 'undefined') {
      if (Shopify.checkout) {
        let lastStep = Shopify.checkout.step;
        const stepMonitor = setInterval(() => {
          if (Shopify.checkout.step !== lastStep) {
            log('Checkout step changed:', lastStep, '->', Shopify.checkout.step);
            if (Shopify.checkout.step === 'complete' || Shopify.checkout.step === 'processing') {
              processOrderCompletionWebhook();
              clearInterval(stepMonitor);
            }
            lastStep = Shopify.checkout.step;
          }
        }, 1000);
        
        setTimeout(() => clearInterval(stepMonitor), 300000); // 5 minutes max
      }
      
      // Monitor cart token changes
      if (Shopify.cart) {
        let lastCartToken = Shopify.cart.token;
        const cartMonitor = setInterval(() => {
          if (Shopify.cart.token !== lastCartToken) {
            log('Cart token changed, processing webhook');
            processOrderCompletionWebhook();
            lastCartToken = Shopify.cart.token;
          }
        }, 2000);
        
        setTimeout(() => clearInterval(cartMonitor), 300000);
      }
    }
    
    // Method 3: URL change monitoring (for SPA-style checkouts)
    let lastUrl = window.location.href;
    const urlMonitor = setInterval(() => {
      if (window.location.href !== lastUrl) {
        log('URL changed from', lastUrl, 'to', window.location.href);
        
        // Process webhook if moving to completion-related URLs
        if (window.location.href.includes('/thank_you') || 
            window.location.href.includes('/orders') ||
            window.location.search.includes('order_id')) {
          processOrderCompletionWebhook();
          setTimeout(() => processOrderCompletionWebhook(), 3000);
        }
        
        lastUrl = window.location.href;
      }
    }, 1000);
    
    setTimeout(() => clearInterval(urlMonitor), 300000);
    
    // Method 4: Periodic check if checkout was initiated
    const periodicCheck = setInterval(() => {
      const checkoutInitiated = sessionStorage.getItem('redyoos_checkout_initiated');
      const jewelryItems = sessionStorage.getItem('jewelryItems');
      
      if (checkoutInitiated && jewelryItems) {
        const initiatedTime = parseInt(checkoutInitiated);
        const timeSinceInitiated = Date.now() - initiatedTime;
        
        // If checkout was initiated more than 5 seconds ago, try webhook
        if (timeSinceInitiated > 5000) {
          log('Periodic check: checkout initiated', timeSinceInitiated / 1000, 'seconds ago');
          processOrderCompletionWebhook();
        }
        
        // Stop checking after 5 minutes
        if (timeSinceInitiated > 300000) {
          sessionStorage.removeItem('redyoos_checkout_initiated');
        }
      }
    }, 5000);
    
    setTimeout(() => clearInterval(periodicCheck), 300000);
    
    // Method 5: Storage event listener (for cross-tab scenarios)
    window.addEventListener('storage', (event) => {
      if (event.key === 'redyoos_checkout_initiated' && event.newValue) {
        log('Checkout initiated in another tab/window');
        setTimeout(() => processOrderCompletionWebhook(), 2000);
      }
    });
    
    // Method 6: Before page unload (last resort)
    window.addEventListener('beforeunload', () => {
      const jewelryItems = sessionStorage.getItem('jewelryItems');
      const checkoutInitiated = sessionStorage.getItem('redyoos_checkout_initiated');
      
      if (jewelryItems && checkoutInitiated) {
        log('Page unloading with pending jewelry items, attempting immediate webhook');
        // Use synchronous beacon for page unload
        processOrderCompletionWebhook(true); // Pass flag for beacon-only mode
      }
    });
  }
  
  /**
   * Main function that orchestrates the order completion webhook process
   * @param {boolean} beaconOnly - Use only beacon method for immediate sending (page unload)
   */
  async function processOrderCompletionWebhook(beaconOnly = false) {
    try {
      log('Starting order completion webhook process', { beaconOnly });
      
      // Check if we have jewelryItems to process
      const jewelryItemsData = sessionStorage.getItem('jewelryItems');
      if (!jewelryItemsData) {
        log('No jewelryItems found in sessionStorage - skipping webhook process');
        return;
      }
      
      // Check if we've already processed this recently (prevent duplicate sends)
      const lastProcessed = sessionStorage.getItem('redyoos_last_webhook_sent');
      if (lastProcessed) {
        const timeSinceLastSend = Date.now() - parseInt(lastProcessed);
        if (timeSinceLastSend < 30000) { // 30 seconds cooldown
          log('Webhook sent recently, skipping to prevent duplicates', timeSinceLastSend / 1000, 'seconds ago');
          return;
        }
      }
      
      let jewelryItems;
      try {
        jewelryItems = JSON.parse(jewelryItemsData);
      } catch (error) {
        log('Error parsing jewelryItems data', error);
        return;
      }
      
      // Extract tokens from the order/checkout data
      const { checkoutToken: extractedCheckoutToken, cartToken: extractedCartToken } = extractOrderTokens();
      
      // Check if jewelry items already have tokens attached
      let finalCartToken = extractedCartToken;
      let finalCheckoutToken = extractedCheckoutToken;
      
      const existingCartToken = jewelryItems[0]?.cart_token;
      const existingCheckoutToken = jewelryItems[0]?.checkout_token;
      
      // Handle cart token priority
      if (existingCartToken) {
        log('Using cart_token already attached to jewelryItems', existingCartToken);
        finalCartToken = existingCartToken;
      } else if (extractedCartToken) {
        log('Using newly extracted cart_token', extractedCartToken);
        finalCartToken = extractedCartToken;
      } else {
        // Try to get from stored session value
        const storedCartToken = sessionStorage.getItem('redyoos_cart_token');
        if (storedCartToken) {
          log('Using cart_token from sessionStorage', storedCartToken);
          finalCartToken = storedCartToken;
        }
      }
      
      // Handle checkout token priority
      if (existingCheckoutToken) {
        log('Using checkout_token already attached to jewelryItems', existingCheckoutToken);
        finalCheckoutToken = existingCheckoutToken;
      } else if (extractedCheckoutToken) {
        log('Using newly extracted checkout_token', extractedCheckoutToken);
        finalCheckoutToken = extractedCheckoutToken;
      } else {
        // Try to get from stored session value
        const storedCheckoutToken = sessionStorage.getItem('redyoos_checkout_token');
        if (storedCheckoutToken) {
          log('Using checkout_token from sessionStorage', storedCheckoutToken);
          finalCheckoutToken = storedCheckoutToken;
        }
      }
      
      // Clean jewelryItems for webhook (remove internal processing metadata)
      const cleanedItems = jewelryItems.map(item => {
        const { 
          cart_token, cart_token_attached_timestamp, cart_token_source, 
          checkout_token, checkout_token_attached_timestamp, checkout_token_source,
          webhook_attempt, 
          ...cleanItem 
        } = item;
        return {
          ...cleanItem,
          webhook_attempt: Date.now() // Only keep processing metadata
        };
      });
      
      log('Prepared jewelryItems for webhook', { 
        itemCount: cleanedItems.length,
        hasCheckoutToken: !!finalCheckoutToken,
        hasCartToken: !!finalCartToken,
        checkoutTokenSource: existingCheckoutToken ? 'jewelry_items' : (extractedCheckoutToken ? 'extraction' : 'session_storage'),
        cartTokenSource: existingCartToken ? 'jewelry_items' : (extractedCartToken ? 'extraction' : 'session_storage')
      });
      
      // Prepare the webhook payload
      const correlationId = sessionStorage.getItem('redyoos_correlation_id') || 
                           'redyoos_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      const sessionId = sessionStorage.getItem('redyoos_session_id') || 
                       'sess_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      
      sessionStorage.setItem('redyoos_correlation_id', correlationId);
      sessionStorage.setItem('redyoos_session_id', sessionId);
      
      const payload = {
        // Top-level identifiers and tokens
        correlationId: correlationId,
        sessionId: sessionId,
        checkout_token: finalCheckoutToken || null,
        cart_token: finalCartToken || null,
        
        // Event information
        event: 'jewelry_order_completed_with_tokens',
        source: 'redyoos_shopify_order',
        version: '2.0',
        orderCompletionTimestamp: new Date().toISOString(),
        token_extraction_timestamp: new Date().toISOString(),
        
        // Jewelry data (without tokens in each item)
        jewelryItems: cleanedItems,
        jewelryItemsCount: cleanedItems.length,
        jewelryItemsSummary: cleanedItems.map(item => 
          `${item.jewelry_type || 'jewelry'} ($${item.estimated_value_min || 'N/A'}-$${item.estimated_value_max || 'N/A'})`
        ).join(', '),
        
        // Metadata
        metadata: {
          userAgent: navigator.userAgent,
          url: window.location.href,
          referrer: document.referrer,
          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
          language: navigator.language,
          viewport: { width: window.innerWidth, height: window.innerHeight },
          pageType: 'checkout_completion',
          hasTokens: !!(checkoutToken || cartToken),
          beaconOnly: beaconOnly,
          checkoutInitiated: sessionStorage.getItem('redyoos_checkout_initiated')
        }
      };
      
      log('Sending enhanced payload to webhook', payload);
      
      let success = false;
      
      if (beaconOnly) {
        // Use beacon for immediate sending during page unload
        success = navigator.sendBeacon(WEBHOOK_URL, JSON.stringify(payload));
        log('Beacon send result:', success);
      } else {
        // Try multiple sending methods
        try {
          // Method 1: Regular fetch
          const response = await fetch(WEBHOOK_URL, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-Webhook-Source': 'redyoos-order-completion'
            },
            body: JSON.stringify(payload)
          });
          
          if (response.ok) {
            success = true;
            log('Webhook sent successfully via fetch');
          } else {
            log('Fetch response not ok:', response.status, response.statusText);
          }
        } catch (fetchError) {
          log('Fetch failed, trying beacon fallback', fetchError);
          
          // Method 2: Beacon fallback
          success = navigator.sendBeacon(WEBHOOK_URL, JSON.stringify(payload));
          log('Beacon fallback result:', success);
        }
      }
      
      if (success) {
        // Mark as successfully sent
        sessionStorage.setItem('redyoos_last_webhook_sent', Date.now().toString());
        
        // Clear jewelryItems from sessionStorage after successful send
        sessionStorage.removeItem('jewelryItems');
        sessionStorage.removeItem('redyoos_checkout_initiated');
        log('Cleared jewelryItems and checkout flags from sessionStorage');
      }
      
      log('Order completion webhook process completed', { success });
      return success;
      
    } catch (error) {
      log('Error in order completion webhook process', error);
      return false;
    }
  }
  
  // =================================================================
  // CHECKOUT TOKEN CAPTURE
  // =================================================================
  
  /**
   * Intercepts checkout form submission to capture checkout token from response
   */
  async function interceptCheckoutFormSubmission(form) {
    return new Promise((resolve) => {
      const originalSubmit = form.submit;
      const originalAction = form.action;
      
      // Override form submission to capture response
      form.addEventListener('submit', async (event) => {
        log('Intercepting checkout form submission to capture checkout token');
        
        try {
          // Don't prevent default - let the form submit normally
          // But also try to capture the response
          
          // Create FormData from the form
          const formData = new FormData(form);
          
          // Try to submit via fetch to capture response (parallel to normal submission)
          fetch(originalAction || '/cart', {
            method: 'POST',
            body: formData,
            redirect: 'manual' // Don't follow redirects automatically
          }).then(async (response) => {
            log('Checkout form submission response received', response.status);
            
            // Check for checkout token in response headers
            const location = response.headers.get('Location');
            if (location) {
              log('Checkout redirect location:', location);
              
              // Extract checkout token from redirect URL
              const redirectUrl = new URL(location, window.location.origin);
              const checkoutToken = redirectUrl.searchParams.get('checkout') || 
                                   redirectUrl.searchParams.get('token') ||
                                   redirectUrl.pathname.split('/').pop();
              
              if (checkoutToken && checkoutToken.length > 10) {
                log('Captured checkout_token from redirect URL', checkoutToken);
                resolve(checkoutToken);
                return;
              }
              
              // If token not in URL params, try to extract from path
              const pathSegments = redirectUrl.pathname.split('/');
              const possibleToken = pathSegments[pathSegments.length - 1];
              if (possibleToken && possibleToken.length > 10 && !possibleToken.includes('.')) {
                log('Captured checkout_token from redirect path', possibleToken);
                resolve(possibleToken);
                return;
              }
            }
            
            // If redirect doesn't contain token, try to parse response body
            if (response.status === 302 || response.status === 303) {
              // This is a redirect response, the token should be in the location header
              log('Checkout redirect detected but no token found in location header');
            }
            
            resolve(null);
          }).catch(error => {
            log('Error intercepting checkout form response', error);
            resolve(null);
          });
          
        } catch (error) {
          log('Error in checkout form interception', error);
          resolve(null);
        }
      }, { once: true }); // Only intercept once
    });
  }
  
  /**
   * Captures checkout token by intercepting the checkout process
   */
  async function captureCheckoutTokenFromProcess() {
    let checkoutToken = null;
    
    // Method 1: Extract from current URL (if we're already on checkout page)
    const urlParams = new URLSearchParams(window.location.search);
    const pathSegments = window.location.pathname.split('/');
    
    if (urlParams.has('checkout')) {
      checkoutToken = urlParams.get('checkout');
      log('Captured checkout_token from URL param "checkout"', checkoutToken);
    } else if (urlParams.has('token')) {
      checkoutToken = urlParams.get('token');
      log('Captured checkout_token from URL param "token"', checkoutToken);
    } else if (window.location.pathname.includes('/checkouts/')) {
      // Extract token from checkout URL path like /checkouts/TOKEN_HERE
      const tokenSegment = pathSegments[pathSegments.indexOf('checkouts') + 1];
      if (tokenSegment && tokenSegment.length > 10) {
        checkoutToken = tokenSegment;
        log('Captured checkout_token from checkout URL path', checkoutToken);
      }
    }
    
    // Method 2: Try to get from Shopify checkout object (if available)
    if (!checkoutToken && typeof Shopify !== 'undefined' && Shopify.checkout && Shopify.checkout.token) {
      checkoutToken = Shopify.checkout.token;
      log('Captured checkout_token from Shopify.checkout', checkoutToken);
    }
    
    // Method 3: Look for checkout forms and intercept their submission
    if (!checkoutToken) {
      const checkoutForms = document.querySelectorAll('form[action*="cart"], form[action*="checkout"], form#cart');
      
      for (const form of checkoutForms) {
        log('Setting up checkout form interception for token capture');
        
        // Set up interception for this form
        const token = await interceptCheckoutFormSubmission(form);
        if (token) {
          checkoutToken = token;
          break;
        }
      }
    }
    
    return checkoutToken;
  }
  
  /**
   * Attaches checkout token to jewelryItems when captured
   */
  async function attachCheckoutTokenToJewelryItems(checkoutToken) {
    if (!checkoutToken) {
      log('No checkout token provided to attach');
      return;
    }
    
    const jewelryItemsData = sessionStorage.getItem('jewelryItems');
    if (!jewelryItemsData) {
      log('No jewelryItems found to attach checkout token to');
      return;
    }
    
    try {
      const jewelryItems = JSON.parse(jewelryItemsData);
      
      // Check if items already have this checkout token
      const needsUpdate = jewelryItems.some(item => 
        !item.checkout_token || item.checkout_token !== checkoutToken
      );
      
      if (needsUpdate) {
        const updatedItems = jewelryItems.map(item => ({
          ...item,
          checkout_token: checkoutToken,
          checkout_token_attached_timestamp: new Date().toISOString(),
          checkout_token_source: 'checkout_initiation'
        }));
        
        sessionStorage.setItem('jewelryItems', JSON.stringify(updatedItems));
        sessionStorage.setItem('redyoos_checkout_token', checkoutToken);
        
        log('Successfully attached checkout_token to jewelryItems', {
          checkoutToken: checkoutToken,
          itemCount: updatedItems.length
        });
      } else {
        log('JewelryItems already have current checkout_token, no update needed');
      }
    } catch (error) {
      log('Error attaching checkout token to jewelryItems', error);
    }
  }
  
  /**
   * Monitors for checkout token availability and captures it
   */
  function monitorCheckoutTokenCapture() {
    // Check periodically if we're on checkout page for token
    const checkoutMonitor = setInterval(async () => {
      if (window.location.pathname.includes('/checkout') || 
          window.location.pathname.includes('/checkouts') ||
          window.location.search.includes('checkout') ||
          window.location.search.includes('token')) {
        
        const checkoutToken = await captureCheckoutTokenFromProcess();
        if (checkoutToken) {
          await attachCheckoutTokenToJewelryItems(checkoutToken);
          clearInterval(checkoutMonitor); // Stop monitoring once captured
        }
      }
    }, 3000); // Check every 3 seconds
    
    // Stop monitoring after 5 minutes
    setTimeout(() => clearInterval(checkoutMonitor), 300000);
    
    // Listen for URL changes that might indicate checkout navigation
    let lastUrl = window.location.href;
    const urlMonitor = setInterval(async () => {
      if (window.location.href !== lastUrl) {
        const newUrl = window.location.href;
        log('URL changed, checking for checkout token', { from: lastUrl, to: newUrl });
        
        if (newUrl.includes('/checkout') || 
            newUrl.includes('/checkouts') ||
            newUrl.includes('checkout') ||
            newUrl.includes('token=')) {
          log('Detected navigation to checkout-related page, attempting token capture');
          
          // Give a moment for the page to load
          setTimeout(async () => {
            const checkoutToken = await captureCheckoutTokenFromProcess();
            if (checkoutToken) {
              await attachCheckoutTokenToJewelryItems(checkoutToken);
              clearInterval(urlMonitor);
            }
          }, 1000);
        }
        lastUrl = newUrl;
      }
    }, 1000);
    
    setTimeout(() => clearInterval(urlMonitor), 300000);
  }

  // =================================================================
  // CART TOKEN ATTACHMENT
  // =================================================================
  
  /**
   * Attaches cart_token to existing jewelryItems when on cart page
   */
  async function attachCartTokenToJewelryItems() {
    // Check if we're on the cart page
    const isCartPage = window.location.pathname.includes('/cart') || 
                      document.querySelector('.cart') ||
                      document.querySelector('#cart') ||
                      document.querySelector('.cart-form');
    
    if (!isCartPage) {
      log('Not on cart page, skipping cart token attachment');
      return;
    }
    
    log('On cart page, attempting to attach cart token to jewelryItems');
    
    // Get existing jewelryItems from sessionStorage
    const jewelryItemsData = sessionStorage.getItem('jewelryItems');
    if (!jewelryItemsData) {
      log('No jewelryItems found in sessionStorage on cart page');
      return;
    }
    
    let jewelryItems;
    try {
      jewelryItems = JSON.parse(jewelryItemsData);
    } catch (error) {
      log('Error parsing jewelryItems on cart page', error);
      return;
    }
    
    // Extract cart token using multiple methods with emphasis on Shopify's official methods
    let cartToken = null;
    
    // Method 1: From Liquid-generated cart data (most reliable and immediate)
    try {
      const cartDataScript = document.getElementById('shopify-cart-data');
      if (cartDataScript) {
        const cartData = JSON.parse(cartDataScript.textContent);
        if (cartData.cart_token) {
          cartToken = cartData.cart_token;
          log('Extracted cart_token from Liquid cart data on cart page', cartToken);
        }
      }
    } catch (error) {
      log('Error parsing cart token from Liquid data', error);
    }
    
    // Method 2: Fetch from Shopify cart.js endpoint (if Liquid data failed)
    if (!cartToken) {
      try {
        const cartResponse = await fetch('/cart.js');
        if (cartResponse.ok) {
          const cartData = await cartResponse.json();
          if (cartData.token) {
            cartToken = cartData.token;
            log('Extracted cart_token from /cart.js endpoint on cart page', cartToken);
          }
        }
      } catch (error) {
        log('Error fetching cart token from /cart.js endpoint', error);
      }
    }
    
    // Method 3: From Shopify global object (if cart.js fetch failed)
    if (!cartToken && typeof Shopify !== 'undefined' && Shopify.cart && Shopify.cart.token) {
      cartToken = Shopify.cart.token;
      log('Extracted cart_token from Shopify.cart on cart page', cartToken);
    }
    
    // Method 4: From window globals that may contain cart data
    if (!cartToken && typeof window.ShopifyAnalytics !== 'undefined' && window.ShopifyAnalytics.meta && window.ShopifyAnalytics.meta.cart && window.ShopifyAnalytics.meta.cart.token) {
      cartToken = window.ShopifyAnalytics.meta.cart.token;
      log('Extracted cart_token from ShopifyAnalytics.meta.cart on cart page', cartToken);
    }
    
    // Method 5: From cart object in window (theme-specific)
    if (!cartToken && typeof window.cart !== 'undefined' && window.cart.token) {
      cartToken = window.cart.token;
      log('Extracted cart_token from window.cart on cart page', cartToken);
    }
    
    // Method 6: From localStorage (fallback)
    if (!cartToken && localStorage.getItem('cartToken')) {
      cartToken = localStorage.getItem('cartToken');
      log('Extracted cart_token from localStorage.cartToken on cart page', cartToken);
    }
    
    if (!cartToken && localStorage.getItem('cart_token')) {
      cartToken = localStorage.getItem('cart_token');
      log('Extracted cart_token from localStorage.cart_token on cart page', cartToken);
    }
    
    // Method 8: From meta tags
    if (!cartToken) {
      const cartMeta = document.querySelector('meta[name="shopify-cart-token"]');
      if (cartMeta) {
        cartToken = cartMeta.getAttribute('content');
        log('Extracted cart_token from meta tag on cart page', cartToken);
      }
    }
    
    // Method 9: From form data attributes
    if (!cartToken) {
      const cartForm = document.querySelector('#cart, .cart-form');
      if (cartForm) {
        const tokenInput = cartForm.querySelector('input[name="token"]');
        if (tokenInput) {
          cartToken = tokenInput.value;
          log('Extracted cart_token from form input on cart page', cartToken);
        }
        
        // Also check data attributes
        if (!cartToken && cartForm.dataset.cartToken) {
          cartToken = cartForm.dataset.cartToken;
          log('Extracted cart_token from form data attribute on cart page', cartToken);
        }
      }
    }
    
    // Method 10: From window.theme or other theme globals
    if (!cartToken && typeof window.theme !== 'undefined' && window.theme.cart_token) {
      cartToken = window.theme.cart_token;
      log('Extracted cart_token from window.theme on cart page', cartToken);
    }
    
    // Method 11: From sessionStorage as final fallback
    if (!cartToken && sessionStorage.getItem('cartToken')) {
      cartToken = sessionStorage.getItem('cartToken');
      log('Extracted cart_token from sessionStorage.cartToken on cart page', cartToken);
    }
    
    if (cartToken) {
      // Check if items already have this cart_token
      const needsUpdate = jewelryItems.some(item => 
        !item.cart_token || item.cart_token !== cartToken
      );
      
      if (needsUpdate) {
        // Attach cart_token to each jewelry item
        const updatedItems = jewelryItems.map(item => ({
          ...item,
          cart_token: cartToken,
          cart_token_attached_timestamp: new Date().toISOString(),
          cart_token_source: 'cart_page_attachment'
        }));
        
        // Store updated items back to sessionStorage
        sessionStorage.setItem('jewelryItems', JSON.stringify(updatedItems));
        log('Successfully attached cart_token to jewelryItems', {
          cartToken: cartToken,
          itemCount: updatedItems.length
        });
        
        // Also store cart token separately for later use
        sessionStorage.setItem('redyoos_cart_token', cartToken);
      } else {
        log('JewelryItems already have current cart_token, no update needed');
      }
      
    } else {
      log('No cart_token found on cart page');
    }
  }
  
  /**
   * Monitors for cart token changes and updates jewelryItems accordingly
   */
  function monitorCartTokenChanges() {
    let lastCartToken = sessionStorage.getItem('redyoos_cart_token');
    
    // Check for cart token changes periodically
    const cartTokenMonitor = setInterval(() => {
      let currentCartToken = null;
      
      // Try to get current cart token from multiple sources
      // Priority: localStorage > Shopify global > sessionStorage
      if (localStorage.getItem('cartToken')) {
        currentCartToken = localStorage.getItem('cartToken');
      } else if (localStorage.getItem('cart_token')) {
        currentCartToken = localStorage.getItem('cart_token');
      } else if (typeof Shopify !== 'undefined' && Shopify.cart && Shopify.cart.token) {
        currentCartToken = Shopify.cart.token;
      } else if (sessionStorage.getItem('cartToken')) {
        currentCartToken = sessionStorage.getItem('cartToken');
      }
      
      // If cart token changed, update jewelryItems
      if (currentCartToken && currentCartToken !== lastCartToken) {
        log('Cart token changed, updating jewelryItems', {
          oldToken: lastCartToken,
          newToken: currentCartToken
        });
        
        const jewelryItemsData = sessionStorage.getItem('jewelryItems');
        if (jewelryItemsData) {
          try {
            const jewelryItems = JSON.parse(jewelryItemsData);
            const updatedItems = jewelryItems.map(item => ({
              ...item,
              cart_token: currentCartToken,
              cart_token_attached_timestamp: new Date().toISOString(),
              cart_token_source: 'token_change_monitor'
            }));
            
            sessionStorage.setItem('jewelryItems', JSON.stringify(updatedItems));
            sessionStorage.setItem('redyoos_cart_token', currentCartToken);
            log('Updated jewelryItems with new cart token');
          } catch (error) {
            log('Error updating jewelryItems with new cart token', error);
          }
        }
        
        lastCartToken = currentCartToken;
      }
    }, 3000); // Check every 3 seconds
    
    // Also listen for localStorage changes (storage events)
    window.addEventListener('storage', (event) => {
      if (event.key === 'cartToken' || event.key === 'cart_token') {
        log('Cart token changed in localStorage, updating jewelryItems');
        setTimeout(async () => {
          await attachCartTokenToJewelryItems(); // Re-run attachment with new token
        }, 500);
      }
    });
    
    // Stop monitoring after 10 minutes to prevent endless checking
    setTimeout(() => clearInterval(cartTokenMonitor), 600000);
  }

  // =================================================================
  // INITIALIZATION
  // =================================================================
  
  // Initialize order completion detection
  async function initializeOrderCompletionWebhook() {
    log('Initializing Redyoos Order Webhook');
    
    // First, try to attach cart token if on cart page
    await attachCartTokenToJewelryItems();
    
    // Try to capture checkout token if we're already on checkout page
    const checkoutToken = await captureCheckoutTokenFromProcess();
    if (checkoutToken) {
      await attachCheckoutTokenToJewelryItems(checkoutToken);
    }
    
    // Start monitoring cart token changes
    monitorCartTokenChanges();
    
    // Start monitoring checkout token capture
    monitorCheckoutTokenCapture();
    
    // Start detecting order completion
    detectOrderCompletion();
    
    // Also check immediately if we're already on a completion page
    setTimeout(() => {
      const isCompletionPage = window.location.pathname.includes('/thank_you') || 
                              window.location.pathname.includes('/orders') ||
                              document.querySelector('.os-order-number') ||
                              document.querySelector('.order-confirmation');
      
      if (isCompletionPage) {
        log('Already on order completion page, processing immediately');
        processOrderCompletionWebhook();
      } else {
        // If not on completion page, try to attach cart token again with delay
        setTimeout(async () => {
          await attachCartTokenToJewelryItems();
        }, 2000);
      }
    }, 500);
    
    // Re-attach cart token when navigating to cart page
    window.addEventListener('popstate', () => {
      setTimeout(async () => {
        await attachCartTokenToJewelryItems();
      }, 1000);
    });
    
    // Also monitor URL changes for SPA-style navigation to cart
    let lastUrl = window.location.href;
    const urlWatcher = setInterval(() => {
      if (window.location.href !== lastUrl) {
        if (window.location.href.includes('/cart')) {
          log('Navigated to cart page, attaching cart token');
          setTimeout(async () => {
            await attachCartTokenToJewelryItems();
          }, 1000);
        }
        lastUrl = window.location.href;
      }
    }, 2000);
    
    // Stop URL watching after 10 minutes
    setTimeout(() => clearInterval(urlWatcher), 600000);
    
    log('Redyoos Order Webhook initialized');
  }
  
  // Wait for DOM to be fully loaded, then initialize
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeOrderCompletionWebhook);
  } else {
    initializeOrderCompletionWebhook();
  }
  
  // Also initialize after a short delay for dynamic content
  setTimeout(initializeOrderCompletionWebhook, 1000);
});
</script>

<!-- 
  INTEGRATION INSTRUCTIONS:
  
  To activate this order completion webhook integration:
  
  1. Add this section to checkout/order completion pages:
     - Go to Shopify Admin > Online Store > Themes
     - Edit the active theme
     - Add to checkout.liquid or thank_you.liquid templates
     - Or add "redyoos-checkout-webhook" to relevant sections
     
  2. Or add via theme customizer:
     - Go to checkout pages in theme customizer
     - Add section > Redyoos Order Webhook
     - Configure webhook URL if needed
     
  3. The section will automatically:
     - Detect order completion using multiple methods
     - Extract checkout_token and cart_token from order data
     - Enhance jewelryItems in sessionStorage with tokens
     - Send enhanced payload to webhook endpoint
     - Clear sessionStorage after successful send
     
  4. Double Payload Flow:
     - First: Shopify's orders/create webhook fires (handled by redyoos-order-attributes.liquid)
     - Second: This enhanced jewelryItems webhook fires with tokens
     
  TROUBLESHOOTING:
  - Check browser console for "[REDYOOS ORDER WEBHOOK]" logs
  - Verify jewelryItems exists in sessionStorage
  - Test webhook endpoint URL separately
  - Ensure proper page detection on order completion
  - Check that order tokens are being extracted successfully
-->