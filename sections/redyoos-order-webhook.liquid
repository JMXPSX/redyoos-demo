{% comment %}
  REDYOOS ORDER WEBHOOK INTEGRATION
  
  This section handles the double payload approach:
  1. Waits for order completion and extracts checkout_token and cart_token
  2. Enhances jewelryItems in sessionStorage with tokens
  3. Sends enhanced jewelryItems payload to webhook endpoint
  
  Purpose: Track jewelry items data with order tokens after checkout completion
  Integration: Detects order completion and processes tokens
  
  WEBHOOK CONFIGURATION:
  - Endpoint URL: https://webhook.site/50c62f38-7160-47fe-9cd8-76b3ad37d796
  - Method: POST
  - Payload: JSON with jewelryItems data enhanced with checkout/cart tokens
  
  FUNCTIONALITY:
  1. Detects order completion on checkout page
  2. Extracts checkout_token and cart_token from order data
  3. Retrieves jewelryItems from sessionStorage
  4. Enhances jewelryItems with extracted tokens
  5. Sends enhanced payload to webhook endpoint
  6. Clears jewelryItems from sessionStorage
  
  ERROR HANDLING:
  - Graceful fallback if token extraction fails
  - Webhook sending continues with available data
  - Console logging for debugging
{% endcomment %}

{% schema %}
{
  "name": "Redyoos Order Webhook",
  "settings": [
    {
      "type": "header",
      "content": "Webhook Configuration"
    },
    {
      "type": "text",
      "id": "webhook_url",
      "label": "Webhook Endpoint URL",
      "default": "https://ccfca2ef201b.ngrok-free.app/api/shopify/webhook",
      "info": "URL where jewelryItems data with tokens will be sent after order completion"
    },
    {
      "type": "checkbox",
      "id": "enable_logging",
      "label": "Enable Console Logging",
      "default": true,
      "info": "Enable debugging logs in browser console"
    }
  ],
  "presets": [
    {
      "name": "Redyoos Order Webhook",
      "category": "Redyoos"
    }
  ]
}
{% endschema %}

<!-- REDYOOS ORDER WEBHOOK HANDLER -->
<!-- This section is invisible and only contains JavaScript functionality -->

<!-- CORS BYPASS INTEGRATION -->
<!-- For CORS-free webhook sending, ensure the redyoos-webhook-proxy section is included -->
<!-- Add {% section 'redyoos-webhook-proxy' %} to your theme template or include it here -->
{% comment %}
  CORS SOLUTION INTEGRATION:
  To use the CORS bypass solution, add this line to your template:
  {% section 'redyoos-webhook-proxy' %}
  
  Or uncomment the line below to include it directly:
{% endcomment %}
{% comment %} {% section 'redyoos-webhook-proxy' %} {% endcomment %}

<!-- Inject Shopify cart data directly from Liquid -->
<script id="shopify-cart-data" type="application/json">
{
  "cart_token": {{ cart.token | json }},
  "cart_id": {{ cart.id | json }},
  "cart_item_count": {{ cart.item_count | json }},
  "cart_total_price": {{ cart.total_price | json }}
}
</script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // =================================================================
  // REDYOOS ORDER WEBHOOK INTEGRATION
  // =================================================================
  
  // Configuration
  const WEBHOOK_URL = {{ section.settings.webhook_url | json }};
  const ENABLE_LOGGING = {{ section.settings.enable_logging | json }};
  
  // Logging utility
  function log(message, data = null) {
    if (ENABLE_LOGGING) {
      if (data) {
        console.log(`[REDYOOS ORDER WEBHOOK] ${message}`, data);
      } else {
        console.log(`[REDYOOS ORDER WEBHOOK] ${message}`);
      }
    }
  }
  
  // =================================================================
  // ORDER COMPLETION & TOKEN EXTRACTION
  // =================================================================
  
  /**
   * Extracts checkout_token and cart_token from Shopify order data
   * @returns {Object} Object containing extracted tokens
   */
  function extractOrderTokens() {
    try {
      let checkoutToken = null;
      let cartToken = null;
      
      // Method 1: Extract from Shopify global objects (if available)
      if (typeof Shopify !== 'undefined') {
        if (Shopify.checkout && Shopify.checkout.token) {
          checkoutToken = Shopify.checkout.token;
          log('Extracted checkout_token from Shopify.checkout', checkoutToken);
        }
        if (Shopify.cart && Shopify.cart.token) {
          cartToken = Shopify.cart.token;
          log('Extracted cart_token from Shopify.cart', cartToken);
        }
      }
      
      // Method 2: Extract from localStorage (most common location for cart token)
      if (!cartToken && localStorage.getItem('cartToken')) {
        cartToken = localStorage.getItem('cartToken');
        log('Extracted cart_token from localStorage.cartToken', cartToken);
      }
      
      if (!cartToken && localStorage.getItem('cart_token')) {
        cartToken = localStorage.getItem('cart_token');
        log('Extracted cart_token from localStorage.cart_token', cartToken);
      }
      
      // Method 3: Extract from meta tags (common Shopify pattern)
      if (!checkoutToken) {
        const checkoutMeta = document.querySelector('meta[name="shopify-checkout-token"]');
        if (checkoutMeta) {
          checkoutToken = checkoutMeta.getAttribute('content');
          log('Extracted checkout_token from meta tag', checkoutToken);
        }
      }
      
      if (!cartToken) {
        const cartMeta = document.querySelector('meta[name="shopify-cart-token"]');
        if (cartMeta) {
          cartToken = cartMeta.getAttribute('content');
          log('Extracted cart_token from meta tag', cartToken);
        }
      }
      
      // Method 4: Extract from URL parameters (checkout pages often have tokens in URL)
      if (!checkoutToken || !cartToken) {
        const urlParams = new URLSearchParams(window.location.search);
        if (!checkoutToken && urlParams.has('checkout_token')) {
          checkoutToken = urlParams.get('checkout_token');
          log('Extracted checkout_token from URL params', checkoutToken);
        }
        if (!cartToken && urlParams.has('cart_token')) {
          cartToken = urlParams.get('cart_token');
          log('Extracted cart_token from URL params', cartToken);
        }
      }
      
      // Method 5: Extract from page JSON-LD or script tags
      if (!checkoutToken || !cartToken) {
        const scriptTags = document.querySelectorAll('script[type="application/json"]');
        scriptTags.forEach(script => {
          try {
            const data = JSON.parse(script.textContent);
            if (!checkoutToken && data.checkout_token) {
              checkoutToken = data.checkout_token;
              log('Extracted checkout_token from JSON script', checkoutToken);
            }
            if (!cartToken && data.cart_token) {
              cartToken = data.cart_token;
              log('Extracted cart_token from JSON script', cartToken);
            }
          } catch (e) {
            // Ignore parsing errors for non-JSON scripts
          }
        });
      }
      
      return { checkoutToken, cartToken };
    } catch (error) {
      log('Error extracting order tokens', error);
      return { checkoutToken: null, cartToken: null };
    }
  }
  
  /**
   * Enhances jewelryItems in sessionStorage with extracted tokens
   * @param {string} checkoutToken - Extracted checkout token
   * @param {string} cartToken - Extracted cart token
   */
  function enhanceJewelryItemsWithTokens(checkoutToken, cartToken) {
    try {
      const jewelryItemsData = sessionStorage.getItem('jewelryItems');
      
      if (!jewelryItemsData) {
        log('No jewelryItems found in sessionStorage to enhance with tokens');
        return;
      }
      
      const jewelryItems = JSON.parse(jewelryItemsData);
      log('Retrieved jewelryItems for token enhancement', { count: jewelryItems.length });
      
      // Enhance each jewelry item with tokens
      const enhancedItems = jewelryItems.map(item => ({
        ...item,
        checkout_token: checkoutToken,
        cart_token: cartToken,
        token_timestamp: new Date().toISOString()
      }));
      
      // Store enhanced items back to sessionStorage
      sessionStorage.setItem('jewelryItems', JSON.stringify(enhancedItems));
      log('Enhanced jewelryItems with tokens', { 
        checkoutToken, 
        cartToken, 
        enhancedCount: enhancedItems.length 
      });
      
      return enhancedItems;
    } catch (error) {
      log('Error enhancing jewelryItems with tokens', error);
      return null;
    }
  }
  
  /**
   * Sends enhanced jewelryItems with tokens to webhook endpoint
   * @param {Array} jewelryItems - Enhanced jewelry items with tokens
   */
  async function sendEnhancedJewelryItemsToWebhook(jewelryItems) {
    try {
      if (!jewelryItems || jewelryItems.length === 0) {
        log('No jewelryItems to send to webhook');
        return false;
      }

      // Generate correlation data
      const correlationId = sessionStorage.getItem('redyoos_correlation_id') || 
                           'redyoos_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      const sessionId = sessionStorage.getItem('redyoos_session_id') || 
                       'sess_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      
      // Store IDs for potential correlation
      sessionStorage.setItem('redyoos_correlation_id', correlationId);
      sessionStorage.setItem('redyoos_session_id', sessionId);
      
      // Prepare enhanced webhook payload
      const payload = {
        // Correlation identifiers
        correlationId: correlationId,
        sessionId: sessionId,
        orderCompletionTimestamp: new Date().toISOString(),
        
        // Event information
        event: 'jewelry_order_completed_with_tokens',
        source: 'redyoos_shopify_order',
        version: '2.0',
        
        // Enhanced jewelry data with tokens
        jewelryItems: jewelryItems,
        jewelryItemsCount: jewelryItems.length,
        jewelryItemsSummary: jewelryItems.map(item => 
          `${item.jewelry_type || 'jewelry'} ($${item.estimated_value_min || 'N/A'}-$${item.estimated_value_max || 'N/A'})`
        ).join(', '),
        
        // Token information
        tokens: {
          checkout_token: jewelryItems[0]?.checkout_token || null,
          cart_token: jewelryItems[0]?.cart_token || null,
          extraction_timestamp: jewelryItems[0]?.token_timestamp || null
        },
        
        // Order and session metadata
        metadata: {
          // Browser/session data
          userAgent: navigator.userAgent,
          url: window.location.href,
          referrer: document.referrer,
          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
          language: navigator.language,
          viewport: {
            width: window.innerWidth,
            height: window.innerHeight
          },
          
          // Order completion context
          pageType: 'checkout_completion',
          hasTokens: !!(jewelryItems[0]?.checkout_token || jewelryItems[0]?.cart_token)
        }
      };

      log('Sending enhanced payload to webhook', payload);

      // Send using fetch with proper headers
      const response = await fetch(WEBHOOK_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Webhook-Source': 'redyoos-order-completion'
        },
        body: JSON.stringify(payload)
      });
      
      if (response.ok) {
        log('Enhanced webhook sent successfully');
        // Clear jewelryItems from sessionStorage after successful send
        sessionStorage.removeItem('jewelryItems');
        log('Cleared jewelryItems from sessionStorage');
        return true;
      } else {
        log('Webhook response not ok:', response.status, response.statusText);
        // Still clear sessionStorage to prevent repeated attempts
        sessionStorage.removeItem('jewelryItems');
        return false;
      }
      
    } catch (error) {
      log('Error sending enhanced webhook', error);
      // Clear sessionStorage even on error to prevent repeated attempts
      sessionStorage.removeItem('jewelryItems');
      return false;
    }
  }

  // =================================================================
  // ORDER COMPLETION DETECTION
  // =================================================================
  
  /**
   * Intercepts checkout initiation and sets up delayed webhook sending
   */
  function interceptCheckoutInitiation() {
    // Method 1: Intercept checkout button clicks (most reliable)
    const checkoutButton = document.querySelector('#checkout, .btn--checkout, [data-checkout-button], button[name="add"][value*="checkout"]');
    if (checkoutButton) {
      log('Found checkout button, adding interception');
      
      checkoutButton.addEventListener('click', async (event) => {
        log('Checkout button clicked - storing session data for webhook enrichment');
        
        // Store the current timestamp to track when checkout was initiated
        sessionStorage.setItem('redyoos_checkout_initiated', Date.now().toString());
        
        // Store enrichment data immediately for later correlation with order webhook
        storeSessionDataForWebhookEnrichment();
        
        // Set up multiple delayed webhook attempts (for post-checkout enrichment)
        setTimeout(() => processOrderCompletionWebhook(), 3000);  // 3 seconds
        setTimeout(() => processOrderCompletionWebhook(), 7000);  // 7 seconds  
        setTimeout(() => processOrderCompletionWebhook(), 12000); // 12 seconds
        setTimeout(() => processOrderCompletionWebhook(), 20000); // 20 seconds
        
      }, true);
    }
    
    // Method 2: Intercept form submissions to /checkout
    const forms = document.querySelectorAll('form');
    forms.forEach(form => {
      if (form.action.includes('/checkout') || form.action.includes('/cart')) {
        log('Found checkout form, adding interception');
        
        form.addEventListener('submit', async (event) => {
          log('Checkout form submitted - storing session data for webhook enrichment');
          
          sessionStorage.setItem('redyoos_checkout_initiated', Date.now().toString());
          
          // Store enrichment data for later correlation
          storeSessionDataForWebhookEnrichment();
          
          // Multiple delayed attempts
          setTimeout(() => processOrderCompletionWebhook(), 3000);
          setTimeout(() => processOrderCompletionWebhook(), 8000);
          setTimeout(() => processOrderCompletionWebhook(), 15000);
          setTimeout(() => processOrderCompletionWebhook(), 25000);
        });
      }
    });
    
    // Method 3: Watch for any button clicks that might trigger checkout
    document.addEventListener('click', async (event) => {
      const target = event.target;
      if (target && (
        target.textContent?.toLowerCase().includes('checkout') ||
        target.textContent?.toLowerCase().includes('complete order') ||
        target.textContent?.toLowerCase().includes('place order') ||
        target.className?.includes('checkout') ||
        target.getAttribute('data-testid')?.includes('checkout')
      )) {
        log('Detected checkout-related button click', target);
        
        sessionStorage.setItem('redyoos_checkout_initiated', Date.now().toString());
        
        // Store enrichment data for later correlation
        storeSessionDataForWebhookEnrichment();
        
        // Staggered webhook attempts
        setTimeout(() => processOrderCompletionWebhook(), 2000);
        setTimeout(() => processOrderCompletionWebhook(), 6000);
        setTimeout(() => processOrderCompletionWebhook(), 12000);
      }
    }, true);
  }
  
  /**
   * Detects order completion using multiple strategies
   */
  function detectOrderCompletion() {
    // First, set up checkout interception
    interceptCheckoutInitiation();
    
    // Method 1: Check if we're already on a completion page
    const isCompletionPage = window.location.pathname.includes('/thank_you') || 
                             window.location.pathname.includes('/orders') ||
                             window.location.search.includes('order_id') ||
                             document.querySelector('.os-order-number') ||
                             document.querySelector('.order-confirmation') ||
                             document.querySelector('[data-order-id]') ||
                             document.querySelector('.checkout-complete');
    
    if (isCompletionPage) {
      log('Already on order completion page, processing immediately');
      processOrderCompletionWebhook();
      
      // Also try with delays in case tokens aren't immediately available
      setTimeout(() => processOrderCompletionWebhook(), 2000);
      setTimeout(() => processOrderCompletionWebhook(), 5000);
      return;
    }
    
    // Method 2: Monitor for Shopify checkout state changes
    if (typeof Shopify !== 'undefined') {
      if (Shopify.checkout) {
        let lastStep = Shopify.checkout.step;
        const stepMonitor = setInterval(() => {
          if (Shopify.checkout.step !== lastStep) {
            log('Checkout step changed:', lastStep, '->', Shopify.checkout.step);
            if (Shopify.checkout.step === 'complete' || Shopify.checkout.step === 'processing') {
              processOrderCompletionWebhook();
              clearInterval(stepMonitor);
            }
            lastStep = Shopify.checkout.step;
          }
        }, 1000);
        
        setTimeout(() => clearInterval(stepMonitor), 300000); // 5 minutes max
      }
      
      // Monitor cart token changes
      if (Shopify.cart) {
        let lastCartToken = Shopify.cart.token;
        const cartMonitor = setInterval(() => {
          if (Shopify.cart.token !== lastCartToken) {
            log('Cart token changed, processing webhook');
            processOrderCompletionWebhook();
            lastCartToken = Shopify.cart.token;
          }
        }, 2000);
        
        setTimeout(() => clearInterval(cartMonitor), 300000);
      }
    }
    
    // Method 3: URL change monitoring (for SPA-style checkouts)
    let lastUrl = window.location.href;
    const urlMonitor = setInterval(() => {
      if (window.location.href !== lastUrl) {
        log('URL changed from', lastUrl, 'to', window.location.href);
        
        // Process webhook if moving to completion-related URLs
        if (window.location.href.includes('/thank_you') || 
            window.location.href.includes('/orders') ||
            window.location.search.includes('order_id')) {
          processOrderCompletionWebhook();
          setTimeout(() => processOrderCompletionWebhook(), 3000);
        }
        
        lastUrl = window.location.href;
      }
    }, 1000);
    
    setTimeout(() => clearInterval(urlMonitor), 300000);
    
    // Method 4: Periodic check if checkout was initiated
    const periodicCheck = setInterval(() => {
      const checkoutInitiated = sessionStorage.getItem('redyoos_checkout_initiated');
      const jewelryItems = sessionStorage.getItem('jewelryItems');
      
      if (checkoutInitiated && jewelryItems) {
        const initiatedTime = parseInt(checkoutInitiated);
        const timeSinceInitiated = Date.now() - initiatedTime;
        
        // If checkout was initiated more than 5 seconds ago, try webhook
        if (timeSinceInitiated > 5000) {
          log('Periodic check: checkout initiated', timeSinceInitiated / 1000, 'seconds ago');
          processOrderCompletionWebhook();
        }
        
        // Stop checking after 5 minutes
        if (timeSinceInitiated > 300000) {
          sessionStorage.removeItem('redyoos_checkout_initiated');
        }
      }
    }, 5000);
    
    setTimeout(() => clearInterval(periodicCheck), 300000);
    
    // Method 5: Storage event listener (for cross-tab scenarios)
    window.addEventListener('storage', (event) => {
      if (event.key === 'redyoos_checkout_initiated' && event.newValue) {
        log('Checkout initiated in another tab/window');
        setTimeout(() => processOrderCompletionWebhook(), 2000);
      }
    });
    
    // Method 6: Before page unload (last resort)
    window.addEventListener('beforeunload', () => {
      const jewelryItems = sessionStorage.getItem('jewelryItems');
      const checkoutInitiated = sessionStorage.getItem('redyoos_checkout_initiated');
      
      if (jewelryItems && checkoutInitiated) {
        log('Page unloading with pending jewelry items, attempting immediate webhook');
        // Use synchronous beacon for page unload
        processOrderCompletionWebhook(true); // Pass flag for beacon-only mode
      }
    });
  }
  
  /**
   * Main function that orchestrates the order completion webhook process
   * @param {boolean} beaconOnly - Use only beacon method for immediate sending (page unload)
   */
  async function processOrderCompletionWebhook(beaconOnly = false) {
    try {
      log('Starting order completion webhook process', { beaconOnly });
      
      // Check if we have jewelryItems to process
      const jewelryItemsData = sessionStorage.getItem('jewelryItems');
      if (!jewelryItemsData) {
        log('No jewelryItems found in sessionStorage - skipping webhook process');
        return;
      }
      
      // Check if we've already processed this recently (prevent duplicate sends)
      const lastProcessed = sessionStorage.getItem('redyoos_last_webhook_sent');
      if (lastProcessed) {
        const timeSinceLastSend = Date.now() - parseInt(lastProcessed);
        if (timeSinceLastSend < 30000) { // 30 seconds cooldown
          log('Webhook sent recently, skipping to prevent duplicates', timeSinceLastSend / 1000, 'seconds ago');
          return;
        }
      }
      
      let jewelryItems;
      try {
        jewelryItems = JSON.parse(jewelryItemsData);
      } catch (error) {
        log('Error parsing jewelryItems data', error);
        return;
      }
      
      // Extract tokens from the order/checkout data
      const { checkoutToken: extractedCheckoutToken, cartToken: extractedCartToken } = extractOrderTokens();
      
      // Check if jewelry items already have tokens attached
      let finalCartToken = extractedCartToken;
      let finalCheckoutToken = extractedCheckoutToken;
      
      const existingCartToken = jewelryItems[0]?.cart_token;
      const existingCheckoutToken = jewelryItems[0]?.checkout_token;
      
      // Handle cart token priority
      if (existingCartToken) {
        log('Using cart_token already attached to jewelryItems', existingCartToken);
        finalCartToken = existingCartToken;
      } else if (extractedCartToken) {
        log('Using newly extracted cart_token', extractedCartToken);
        finalCartToken = extractedCartToken;
      } else {
        // Try to get from stored session value
        const storedCartToken = sessionStorage.getItem('redyoos_cart_token');
        if (storedCartToken) {
          log('Using cart_token from sessionStorage', storedCartToken);
          finalCartToken = storedCartToken;
        }
      }
      
      // Handle checkout token priority - NOTE: checkout_token will be provided by order/create webhook
      if (existingCheckoutToken) {
        log('Using checkout_token already attached to jewelryItems', existingCheckoutToken);
        finalCheckoutToken = existingCheckoutToken;
      } else if (extractedCheckoutToken) {
        log('Using newly extracted checkout_token', extractedCheckoutToken);
        finalCheckoutToken = extractedCheckoutToken;
      } else {
        // For webhook enrichment approach, checkout_token will be null until order/create webhook provides it
        log('No checkout_token available yet - will be enriched via order/create webhook');
        finalCheckoutToken = null;
      }
      
      // Try to retrieve enrichment data stored during checkout initiation
      let enrichmentData = null;
      if (finalCartToken) {
        const enrichmentKey = `redyoos_enrichment_cart_${finalCartToken}`;
        const storedData = localStorage.getItem(enrichmentKey);
        if (storedData) {
          try {
            enrichmentData = JSON.parse(storedData);
            log('Retrieved enrichment data for correlation', { key: enrichmentKey });
          } catch (error) {
            log('Error parsing enrichment data', error);
          }
        }
      }
      
      // Clean jewelryItems for webhook (remove internal processing metadata AND redundant session_id)
      const cleanedItems = jewelryItems.map(item => {
        const { 
          cart_token, cart_token_attached_timestamp, cart_token_source, 
          checkout_token, checkout_token_attached_timestamp, checkout_token_source,
          webhook_attempt,
          session_id, // Remove redundant session_id from individual items
          ...cleanItem 
        } = item;
        return {
          ...cleanItem,
          webhook_attempt: Date.now() // Only keep processing metadata
        };
      });
      
      log('Prepared jewelryItems for webhook', { 
        itemCount: cleanedItems.length,
        hasCheckoutToken: !!finalCheckoutToken,
        hasCartToken: !!finalCartToken,
        checkoutTokenSource: existingCheckoutToken ? 'jewelry_items' : (extractedCheckoutToken ? 'extraction' : 'session_storage'),
        cartTokenSource: existingCartToken ? 'jewelry_items' : (extractedCartToken ? 'extraction' : 'session_storage')
      });
      
      // Prepare the webhook payload
      const correlationId = sessionStorage.getItem('redyoos_correlation_id') || 
                           'redyoos_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      const sessionId = sessionStorage.getItem('redyoos_session_id') || 
                       'sess_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      
      sessionStorage.setItem('redyoos_correlation_id', correlationId);
      sessionStorage.setItem('redyoos_session_id', sessionId);
      
      // Prepare session-based payload for your backend correlation
      const sessionBasedPayload = {
        // Session ID for correlation (matches what will be in order.note_attributes)
        session_id: sessionStorage.getItem('custom_session_id'),
        
        // Events data (jewelryItems) as requested
        events: {
          jewelryItems: cleanedItems,
          jewelryItemsCount: cleanedItems.length,
          jewelryItemsSummary: cleanedItems.map(item => 
            `${item.calculatedValues?.metalType || 'jewelry'} (${item.calculatedValues?.afterFeesValue || 'N/A'})`
          ).join(', '),
          
          // Additional event context
          eventType: 'jewelry_order_completed',
          timestamp: new Date().toISOString(),
          source: 'redyoos_frontend_session'
        },
        
        // Metadata for debugging and correlation
        metadata: {
          correlationId: correlationId,
          sessionId: sessionId,
          checkout_token: finalCheckoutToken || null,
          cart_token: finalCartToken || null,
          url: window.location.href,
          userAgent: navigator.userAgent,
          hasEnrichmentData: !!enrichmentData
        }
      };

      const payload = {
        // Top-level identifiers and tokens (legacy format for existing systems)
        correlationId: correlationId,
        sessionId: sessionId,
        checkout_token: finalCheckoutToken || null,
        cart_token: finalCartToken || null,
        
        // Event information
        event: 'jewelry_order_completed_with_tokens',
        source: 'redyoos_shopify_order',
        version: '2.0',
        orderCompletionTimestamp: new Date().toISOString(),
        token_extraction_timestamp: new Date().toISOString(),
        
        // NEW: Session-based payload for your backend correlation
        session_payload: sessionBasedPayload,
        
        // Jewelry data (without tokens in each item)
        jewelryItems: cleanedItems,
        jewelryItemsCount: cleanedItems.length,
        jewelryItemsSummary: cleanedItems.map(item => 
          `${item.calculatedValues?.metalType || 'jewelry'} (${item.calculatedValues?.afterFeesValue || 'N/A'})`
        ).join(', '),
        
        // Metadata (enhanced with enrichment approach)
        metadata: {
          userAgent: navigator.userAgent,
          url: window.location.href,
          referrer: document.referrer,
          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
          language: navigator.language,
          viewport: { width: window.innerWidth, height: window.innerHeight },
          pageType: 'checkout_completion',
          hasTokens: !!(finalCheckoutToken || finalCartToken),
          beaconOnly: beaconOnly,
          checkoutInitiated: sessionStorage.getItem('redyoos_checkout_initiated'),
          
          // Webhook enrichment approach metadata
          webhookEnrichmentApproach: true,
          hasEnrichmentData: !!enrichmentData,
          enrichmentNote: 'checkout_token will be provided via order/create webhook for correlation',
          
          // Include key enrichment data points for correlation
          ...(enrichmentData ? {
            checkout_initiated_url: enrichmentData.checkout_initiated_url,
            checkout_initiated_timestamp: enrichmentData.checkout_initiated_timestamp,
            session_timestamp: enrichmentData.session_timestamp,
            cart_context_at_checkout: {
              cart_total: enrichmentData.cart_total,
              cart_item_count: enrichmentData.cart_item_count
            }
          } : {})
        },
        
        // Include enrichment data for backend correlation (if available)
        ...(enrichmentData ? {
          enrichment_session_data: {
            session_id: enrichmentData.session_id,
            correlation_id: enrichmentData.correlation_id,
            jewelry_items_summary: enrichmentData.jewelryItemsSummary,
            cart_line_items_at_checkout: enrichmentData.cart_line_items,
            customer_context: enrichmentData.customer_context
          }
        } : {})
      };
      
      log('Session-based payload for correlation', sessionBasedPayload);
      
      // STEP 3: Send session payload to your dedicated backend endpoint
      // This matches your requested format: {session_id, events}
      const success = await sendSessionPayloadToBackend(sessionBasedPayload);
      
      // Handle cleanup after sending session payload
      handleWebhookResult(success);
      
      function handleWebhookResult(webhookSuccess) {
        if (webhookSuccess) {
          // Mark as successfully sent
          sessionStorage.setItem('redyoos_last_webhook_sent', Date.now().toString());
          
          // Clear jewelryItems from sessionStorage after successful send
          sessionStorage.removeItem('jewelryItems');
          sessionStorage.removeItem('redyoos_checkout_initiated');
          log('Cleared jewelryItems and checkout flags from sessionStorage');
        }
        
        log('Order completion webhook process completed', { success: webhookSuccess });
        return webhookSuccess;
      }
      
    } catch (error) {
      log('Error in order completion webhook process', error);
      return false;
    }
  }
  
  // =================================================================
  // SESSION DATA STORAGE FOR WEBHOOK ENRICHMENT
  // =================================================================
  
  /**
   * Stores session data for later correlation with order/create webhook
   * This data will be used to enrich the webhook payload post-checkout
   */
  function storeSessionDataForWebhookEnrichment() {
    const jewelryItemsData = sessionStorage.getItem('jewelryItems');
    if (!jewelryItemsData) {
      log('No jewelryItems found to store for webhook enrichment');
      return;
    }
    
    try {
      const jewelryItems = JSON.parse(jewelryItemsData);
      const cartToken = sessionStorage.getItem('redyoos_cart_token') || 
                       localStorage.getItem('cartToken') || 
                       (typeof Shopify !== 'undefined' && Shopify.cart && Shopify.cart.token);
      
      // Create enrichment data structure
      const enrichmentData = {
        // Primary correlation keys
        cart_token: cartToken,
        session_id: sessionStorage.getItem('redyoos_session_id'),
        correlation_id: sessionStorage.getItem('redyoos_correlation_id'),
        
        // Jewelry items data
        jewelryItems: jewelryItems,
        jewelryItemsCount: jewelryItems.length,
        jewelryItemsSummary: jewelryItems.map(item => 
          `${item.jewelry_type || 'jewelry'} ($${item.estimated_value_min || 'N/A'}-$${item.estimated_value_max || 'N/A'})`
        ).join(', '),
        
        // Session metadata for correlation
        checkout_initiated_timestamp: sessionStorage.getItem('redyoos_checkout_initiated'),
        checkout_initiated_url: window.location.href,
        user_agent: navigator.userAgent,
        session_timestamp: new Date().toISOString(),
        
        // Cart context for correlation
        cart_line_items: Array.from(document.querySelectorAll('.cart-item')).map(item => {
          const titleElement = item.querySelector('.cart-item__name');
          const priceElement = item.querySelector('.price');
          const quantityElement = item.querySelector('.quantity__input');
          
          return {
            title: titleElement?.textContent?.trim() || 'Unknown Product',
            price: priceElement?.textContent?.trim() || 'N/A',
            quantity: quantityElement?.value || '1',
            productUrl: titleElement?.getAttribute('href') || null
          };
        }),
        
        // Additional correlation points
        cart_total: document.querySelector('.totals__total-value')?.textContent?.trim() || 'N/A',
        cart_item_count: document.querySelectorAll('.cart-item').length || 0,
        customer_context: {
          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
          language: navigator.language,
          viewport: { width: window.innerWidth, height: window.innerHeight }
        }
      };
      
      // Store enrichment data with multiple correlation keys for webhook matching
      const storageKeys = [];
      
      if (cartToken) {
        const cartKey = `redyoos_enrichment_cart_${cartToken}`;
        localStorage.setItem(cartKey, JSON.stringify(enrichmentData));
        storageKeys.push(cartKey);
        log('Stored enrichment data with cart_token key', cartKey);
      }
      
      if (enrichmentData.session_id) {
        const sessionKey = `redyoos_enrichment_session_${enrichmentData.session_id}`;
        localStorage.setItem(sessionKey, JSON.stringify(enrichmentData));
        storageKeys.push(sessionKey);
        log('Stored enrichment data with session_id key', sessionKey);
      }
      
      if (enrichmentData.correlation_id) {
        const corrKey = `redyoos_enrichment_corr_${enrichmentData.correlation_id}`;
        localStorage.setItem(corrKey, JSON.stringify(enrichmentData));
        storageKeys.push(corrKey);
        log('Stored enrichment data with correlation_id key', corrKey);
      }
      
      // Store timestamp-based key as fallback
      const timestampKey = `redyoos_enrichment_${Date.now()}`;
      localStorage.setItem(timestampKey, JSON.stringify({
        ...enrichmentData,
        storage_keys: storageKeys
      }));
      
      log('Successfully stored session data for webhook enrichment', {
        keys: storageKeys.length + 1,
        jewelryItemsCount: jewelryItems.length,
        hasCartToken: !!cartToken
      });
      
      // Clean up old enrichment data (keep only last 10 entries)
      cleanupOldEnrichmentData();
      
    } catch (error) {
      log('Error storing session data for webhook enrichment', error);
    }
  }
  
  /**
   * Cleans up old enrichment data to prevent localStorage bloat
   */
  function cleanupOldEnrichmentData() {
    try {
      const enrichmentKeys = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('redyoos_enrichment_')) {
          enrichmentKeys.push(key);
        }
      }
      
      // Sort by timestamp (newer first)
      enrichmentKeys.sort((a, b) => {
        const timestampA = a.includes('redyoos_enrichment_cart_') ? 0 : 
                          a.includes('redyoos_enrichment_session_') ? 0 :
                          a.includes('redyoos_enrichment_corr_') ? 0 :
                          parseInt(a.split('_').pop()) || 0;
        const timestampB = b.includes('redyoos_enrichment_cart_') ? 0 : 
                          b.includes('redyoos_enrichment_session_') ? 0 :
                          b.includes('redyoos_enrichment_corr_') ? 0 :
                          parseInt(b.split('_').pop()) || 0;
        return timestampB - timestampA;
      });
      
      // Remove old entries (keep latest 20)
      if (enrichmentKeys.length > 20) {
        for (let i = 20; i < enrichmentKeys.length; i++) {
          localStorage.removeItem(enrichmentKeys[i]);
        }
        log('Cleaned up old enrichment data', { removed: enrichmentKeys.length - 20 });
      }
    } catch (error) {
      log('Error cleaning up enrichment data', error);
    }
  }

  // =================================================================
  // CART TOKEN ATTACHMENT
  // =================================================================
  
  /**
   * Attaches cart_token to existing jewelryItems when on cart page
   */
  async function attachCartTokenToJewelryItems() {
    // Check if we're on the cart page
    const isCartPage = window.location.pathname.includes('/cart') || 
                      document.querySelector('.cart') ||
                      document.querySelector('#cart') ||
                      document.querySelector('.cart-form');
    
    if (!isCartPage) {
      log('Not on cart page, skipping cart token attachment');
      return;
    }
    
    log('On cart page, attempting to attach cart token to jewelryItems');
    
    // Get existing jewelryItems from sessionStorage
    const jewelryItemsData = sessionStorage.getItem('jewelryItems');
    if (!jewelryItemsData) {
      log('No jewelryItems found in sessionStorage on cart page');
      return;
    }
    
    let jewelryItems;
    try {
      jewelryItems = JSON.parse(jewelryItemsData);
    } catch (error) {
      log('Error parsing jewelryItems on cart page', error);
      return;
    }
    
    // Extract cart token using multiple methods with emphasis on Shopify's official methods
    let cartToken = null;
    
    // Method 1: From Liquid-generated cart data (most reliable and immediate)
    try {
      const cartDataScript = document.getElementById('shopify-cart-data');
      if (cartDataScript) {
        const cartData = JSON.parse(cartDataScript.textContent);
        if (cartData.cart_token) {
          cartToken = cartData.cart_token;
          log('Extracted cart_token from Liquid cart data on cart page', cartToken);
        }
      }
    } catch (error) {
      log('Error parsing cart token from Liquid data', error);
    }
    
    // Method 2: Fetch from Shopify cart.js endpoint (if Liquid data failed)
    if (!cartToken) {
      try {
        const cartResponse = await fetch('/cart.js');
        if (cartResponse.ok) {
          const cartData = await cartResponse.json();
          if (cartData.token) {
            cartToken = cartData.token;
            log('Extracted cart_token from /cart.js endpoint on cart page', cartToken);
          }
        }
      } catch (error) {
        log('Error fetching cart token from /cart.js endpoint', error);
      }
    }
    
    // Method 3: From Shopify global object (if cart.js fetch failed)
    if (!cartToken && typeof Shopify !== 'undefined' && Shopify.cart && Shopify.cart.token) {
      cartToken = Shopify.cart.token;
      log('Extracted cart_token from Shopify.cart on cart page', cartToken);
    }
    
    // Method 4: From window globals that may contain cart data
    if (!cartToken && typeof window.ShopifyAnalytics !== 'undefined' && window.ShopifyAnalytics.meta && window.ShopifyAnalytics.meta.cart && window.ShopifyAnalytics.meta.cart.token) {
      cartToken = window.ShopifyAnalytics.meta.cart.token;
      log('Extracted cart_token from ShopifyAnalytics.meta.cart on cart page', cartToken);
    }
    
    // Method 5: From cart object in window (theme-specific)
    if (!cartToken && typeof window.cart !== 'undefined' && window.cart.token) {
      cartToken = window.cart.token;
      log('Extracted cart_token from window.cart on cart page', cartToken);
    }
    
    // Method 6: From localStorage (fallback)
    if (!cartToken && localStorage.getItem('cartToken')) {
      cartToken = localStorage.getItem('cartToken');
      log('Extracted cart_token from localStorage.cartToken on cart page', cartToken);
    }
    
    if (!cartToken && localStorage.getItem('cart_token')) {
      cartToken = localStorage.getItem('cart_token');
      log('Extracted cart_token from localStorage.cart_token on cart page', cartToken);
    }
    
    // Method 8: From meta tags
    if (!cartToken) {
      const cartMeta = document.querySelector('meta[name="shopify-cart-token"]');
      if (cartMeta) {
        cartToken = cartMeta.getAttribute('content');
        log('Extracted cart_token from meta tag on cart page', cartToken);
      }
    }
    
    // Method 9: From form data attributes
    if (!cartToken) {
      const cartForm = document.querySelector('#cart, .cart-form');
      if (cartForm) {
        const tokenInput = cartForm.querySelector('input[name="token"]');
        if (tokenInput) {
          cartToken = tokenInput.value;
          log('Extracted cart_token from form input on cart page', cartToken);
        }
        
        // Also check data attributes
        if (!cartToken && cartForm.dataset.cartToken) {
          cartToken = cartForm.dataset.cartToken;
          log('Extracted cart_token from form data attribute on cart page', cartToken);
        }
      }
    }
    
    // Method 10: From window.theme or other theme globals
    if (!cartToken && typeof window.theme !== 'undefined' && window.theme.cart_token) {
      cartToken = window.theme.cart_token;
      log('Extracted cart_token from window.theme on cart page', cartToken);
    }
    
    // Method 11: From sessionStorage as final fallback
    if (!cartToken && sessionStorage.getItem('cartToken')) {
      cartToken = sessionStorage.getItem('cartToken');
      log('Extracted cart_token from sessionStorage.cartToken on cart page', cartToken);
    }
    
    if (cartToken) {
      // Check if items already have this cart_token
      const needsUpdate = jewelryItems.some(item => 
        !item.cart_token || item.cart_token !== cartToken
      );
      
      if (needsUpdate) {
        // Attach cart_token to each jewelry item
        const updatedItems = jewelryItems.map(item => ({
          ...item,
          cart_token: cartToken,
          cart_token_attached_timestamp: new Date().toISOString(),
          cart_token_source: 'cart_page_attachment'
        }));
        
        // Store updated items back to sessionStorage
        sessionStorage.setItem('jewelryItems', JSON.stringify(updatedItems));
        log('Successfully attached cart_token to jewelryItems', {
          cartToken: cartToken,
          itemCount: updatedItems.length
        });
        
        // Also store cart token separately for later use
        sessionStorage.setItem('redyoos_cart_token', cartToken);
      } else {
        log('JewelryItems already have current cart_token, no update needed');
      }
      
    } else {
      log('No cart_token found on cart page');
    }
  }
  
  /**
   * Monitors for cart token changes and updates jewelryItems accordingly
   */
  function monitorCartTokenChanges() {
    let lastCartToken = sessionStorage.getItem('redyoos_cart_token');
    
    // Check for cart token changes periodically
    const cartTokenMonitor = setInterval(() => {
      let currentCartToken = null;
      
      // Try to get current cart token from multiple sources
      // Priority: localStorage > Shopify global > sessionStorage
      if (localStorage.getItem('cartToken')) {
        currentCartToken = localStorage.getItem('cartToken');
      } else if (localStorage.getItem('cart_token')) {
        currentCartToken = localStorage.getItem('cart_token');
      } else if (typeof Shopify !== 'undefined' && Shopify.cart && Shopify.cart.token) {
        currentCartToken = Shopify.cart.token;
      } else if (sessionStorage.getItem('cartToken')) {
        currentCartToken = sessionStorage.getItem('cartToken');
      }
      
      // If cart token changed, update jewelryItems
      if (currentCartToken && currentCartToken !== lastCartToken) {
        log('Cart token changed, updating jewelryItems', {
          oldToken: lastCartToken,
          newToken: currentCartToken
        });
        
        const jewelryItemsData = sessionStorage.getItem('jewelryItems');
        if (jewelryItemsData) {
          try {
            const jewelryItems = JSON.parse(jewelryItemsData);
            const updatedItems = jewelryItems.map(item => ({
              ...item,
              cart_token: currentCartToken,
              cart_token_attached_timestamp: new Date().toISOString(),
              cart_token_source: 'token_change_monitor'
            }));
            
            sessionStorage.setItem('jewelryItems', JSON.stringify(updatedItems));
            sessionStorage.setItem('redyoos_cart_token', currentCartToken);
            log('Updated jewelryItems with new cart token');
          } catch (error) {
            log('Error updating jewelryItems with new cart token', error);
          }
        }
        
        lastCartToken = currentCartToken;
      }
    }, 3000); // Check every 3 seconds
    
    // Also listen for localStorage changes (storage events)
    window.addEventListener('storage', (event) => {
      if (event.key === 'cartToken' || event.key === 'cart_token') {
        log('Cart token changed in localStorage, updating jewelryItems');
        setTimeout(async () => {
          await attachCartTokenToJewelryItems(); // Re-run attachment with new token
        }, 500);
      }
    });
    
    // Stop monitoring after 10 minutes to prevent endless checking
    setTimeout(() => clearInterval(cartTokenMonitor), 600000);
  }

  // =================================================================
  // SESSION ID INJECTION TO CART ATTRIBUTES
  // =================================================================
  
  /**
   * Injects session_id as hidden input into all cart forms (DOM manipulation method)
   */
  function injectSessionIdToCartForms() {
    const sessionId = sessionStorage.getItem('custom_session_id');
    if (!sessionId) {
      log('No session ID found, skipping cart form injection');
      return;
    }
    
    // Find all potential cart forms
    const cartForms = document.querySelectorAll([
      'form[action*="/cart"]',
      'form[data-type="add-to-cart-form"]', 
      '#cart',
      '.cart-form',
      'form[name="cart"]'
    ].join(', '));
    
    let injectedCount = 0;
    cartForms.forEach(form => {
      // Check if session_id input already exists
      if (!form.querySelector('input[name="attributes[session_id]"]')) {
        const sessionIdInput = document.createElement('input');
        sessionIdInput.type = 'hidden';
        sessionIdInput.name = 'attributes[session_id]';
        sessionIdInput.id = 'session_id_input_' + Date.now();
        sessionIdInput.value = sessionId;
        form.appendChild(sessionIdInput);
        injectedCount++;
      }
    });
    
    if (injectedCount > 0) {
      log(`Injected session_id into ${injectedCount} cart forms`, sessionId);
    }
  }
  
  /**
   * Intercepts form submissions and adds session_id dynamically
   */
  function interceptFormSubmissions() {
    document.addEventListener('submit', function(event) {
      const form = event.target;
      const sessionId = sessionStorage.getItem('custom_session_id');
      
      if (!sessionId) return;
      
      // Check if this is a cart/checkout related form
      const isCartForm = form.action.includes('/cart') || 
                        form.dataset.type === 'add-to-cart-form' ||
                        form.action.includes('/checkout') ||
                        form.classList.contains('cart-form') ||
                        form.id === 'cart';
      
      if (isCartForm && !form.querySelector('input[name="attributes[session_id]"]')) {
        const sessionIdInput = document.createElement('input');
        sessionIdInput.type = 'hidden';
        sessionIdInput.name = 'attributes[session_id]';
        sessionIdInput.value = sessionId;
        form.appendChild(sessionIdInput);
        log('Dynamically added session_id to form submission', sessionId);
      }
    });
  }

  /**
   * Updates cart attributes via Shopify AJAX API (most reliable method)
   */
  async function attachSessionIdToCartViaAJAX() {
    const sessionId = sessionStorage.getItem('custom_session_id');
    if (!sessionId) {
      log('No session ID found, skipping AJAX cart update');
      return false;
    }
    
    try {
      const response = await fetch('/cart/update.js', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          attributes: {
            'session_id': sessionId
          }
        })
      });
      
      if (response.ok) {
        const cartData = await response.json();
        log('Successfully attached session_id to cart via AJAX', sessionId);
        return true;
      } else {
        log('Failed to attach session_id via AJAX', response.status);
        return false;
      }
    } catch (error) {
      log('Error attaching session_id via AJAX', error);
      return false;
    }
  }
  
  /**
   * Comprehensive session ID attachment using multiple methods
   */
  async function attachSessionIdToCart() {
    const sessionId = sessionStorage.getItem('custom_session_id');
    if (!sessionId) {
      log('No session ID found, skipping all attachment methods');
      return;
    }
    
    log('Starting comprehensive session_id attachment', sessionId);
    
    // Method 1: AJAX cart update (most reliable)
    const ajaxSuccess = await attachSessionIdToCartViaAJAX();
    
    // Method 2: DOM injection (backup)
    injectSessionIdToCartForms();
    
    // Method 3: Form submission interception (final backup)  
    interceptFormSubmissions();
    
    // Retry DOM injection periodically for dynamically loaded forms
    setTimeout(() => injectSessionIdToCartForms(), 2000);
    setTimeout(() => injectSessionIdToCartForms(), 5000);
    
    log('Completed session_id attachment using all methods');
  }

  // =================================================================
  // SESSION PAYLOAD BACKEND COMMUNICATION
  // =================================================================
  
  /**
   * Sends session-based payload to your backend endpoint for correlation
   * Format: { session_id: "...", events: {...} }
   */
  async function sendSessionPayloadToBackend(sessionPayload) {
    // You can customize this endpoint URL via the webhook settings
    const sessionEndpoint = WEBHOOK_URL; // For now using same endpoint, but you can change this
    
    if (!sessionPayload.session_id) {
      log('No session_id in payload, skipping session backend call');
      return false;
    }
    
    try {
      log('Sending session payload to backend for correlation', sessionPayload);
      
      // Use multiple sending methods for reliability
      let success = false;
      
      // Method 1: sendBeacon (most reliable for cross-origin)
      const payloadString = JSON.stringify(sessionPayload);
      success = navigator.sendBeacon(sessionEndpoint, payloadString);
      
      if (success) {
        log('Session payload sent successfully via sendBeacon');
        return true;
      }
      
      // Method 2: Fetch with no-cors mode (backup)
      try {
        await fetch(sessionEndpoint, {
          method: 'POST',
          mode: 'no-cors',
          headers: {
            'Content-Type': 'application/json',
            'X-Webhook-Source': 'redyoos-session-payload'
          },
          body: payloadString
        });
        
        log('Session payload sent successfully via no-cors fetch');
        return true;
      } catch (fetchError) {
        log('No-cors fetch failed for session payload', fetchError);
      }
      
      // Method 3: Final beacon attempt with blob
      try {
        const blob = new Blob([payloadString], { type: 'application/json' });
        success = navigator.sendBeacon(sessionEndpoint, blob);
        log('Session payload beacon attempt result:', success);
        return success;
      } catch (blobError) {
        log('All session payload sending methods failed', blobError);
        return false;
      }
      
    } catch (error) {
      log('Error sending session payload to backend', error);
      return false;
    }
  }

  // =================================================================
  // SESSION ID REGENERATION FOR NEW JEWELRY EVALUATIONS
  // =================================================================
  
  /**
   * Global function to force new jewelry session across all pages
   */
  window.RedyoosStartNewSession = function() {
    const newSessionId = Date.now() + "-" + Math.random().toString(36).substr(2, 9);
    sessionStorage.setItem("custom_session_id", newSessionId);
    
    // Clear all jewelry-related session data
    sessionStorage.removeItem('jewelryItems');
    sessionStorage.removeItem('calculatedValues');
    sessionStorage.removeItem('uploadedImages');
    sessionStorage.removeItem('currentJewelryItemIndex');
    sessionStorage.removeItem('redyoos_last_jewelry_session');
    
    log('Started fresh jewelry session with new session_id:', newSessionId);
    return newSessionId;
  };
  
  /**
   * Detects new session triggers globally across all pages
   */
  function setupGlobalSessionTriggers() {
    document.addEventListener('click', function(event) {
      const target = event.target;
      const targetText = target.textContent?.toLowerCase() || '';
      
      // Global triggers for new jewelry sessions
      const globalSessionTriggers = [
        'get a buy back mail kit',
        'start new evaluation',
        'new jewelry evaluation',
        'begin new appraisal',
        'evaluate another item',
        'add another item',
        'start over',
        'fresh evaluation'
      ];
      
      const shouldTriggerNewSession = globalSessionTriggers.some(trigger => 
        targetText.includes(trigger) ||
        target.getAttribute('href')?.includes('new_session=true') ||
        target.id?.toLowerCase().includes('new_session') ||
        target.className?.toLowerCase().includes('new_session')
      );
      
      if (shouldTriggerNewSession) {
        log('Global new session trigger detected:', targetText);
        window.RedyoosStartNewSession();
      }
    });
  }

  // =================================================================
  // INITIALIZATION
  // =================================================================
  
  // Initialize order completion detection
  async function initializeOrderCompletionWebhook() {
    log('Initializing Redyoos Order Webhook');
    
    // Set up global session triggers
    setupGlobalSessionTriggers();
    
    // First, attach session ID to cart using multiple methods
    await attachSessionIdToCart();
    
    // Then, try to attach cart token if on cart page
    await attachCartTokenToJewelryItems();
    
    // Store enrichment data if we have jewelryItems
    const jewelryItemsData = sessionStorage.getItem('jewelryItems');
    if (jewelryItemsData) {
      storeSessionDataForWebhookEnrichment();
    }
    
    // Start monitoring cart token changes
    monitorCartTokenChanges();
    
    // Start detecting order completion
    detectOrderCompletion();
    
    // Also check immediately if we're already on a completion page
    setTimeout(() => {
      const isCompletionPage = window.location.pathname.includes('/thank_you') || 
                              window.location.pathname.includes('/orders') ||
                              document.querySelector('.os-order-number') ||
                              document.querySelector('.order-confirmation');
      
      if (isCompletionPage) {
        log('Already on order completion page, processing immediately');
        processOrderCompletionWebhook();
      } else {
        // If not on completion page, try to attach cart token again with delay
        setTimeout(async () => {
          await attachCartTokenToJewelryItems();
        }, 2000);
      }
    }, 500);
    
    // Re-attach session ID and cart token when navigating
    window.addEventListener('popstate', () => {
      setTimeout(async () => {
        await attachSessionIdToCart();
        await attachCartTokenToJewelryItems();
      }, 1000);
    });
    
    // Also monitor URL changes for SPA-style navigation
    let lastUrl = window.location.href;
    const urlWatcher = setInterval(() => {
      if (window.location.href !== lastUrl) {
        if (window.location.href.includes('/cart') || 
            window.location.href.includes('/product') ||
            window.location.href.includes('/checkout')) {
          log('Navigated to cart/product/checkout page, re-attaching session ID and cart token');
          setTimeout(async () => {
            await attachSessionIdToCart();
            await attachCartTokenToJewelryItems();
          }, 1000);
        }
        lastUrl = window.location.href;
      }
    }, 2000);
    
    // Periodic session ID reattachment to ensure it's always present
    const sessionIdWatcher = setInterval(async () => {
      const sessionId = sessionStorage.getItem('custom_session_id');
      if (sessionId) {
        // Check if cart forms have session ID, if not, re-attach
        const cartForms = document.querySelectorAll('form[action*="/cart"], form[data-type="add-to-cart-form"]');
        let needsReattach = false;
        
        cartForms.forEach(form => {
          if (!form.querySelector('input[name="attributes[session_id]"]')) {
            needsReattach = true;
          }
        });
        
        if (needsReattach) {
          log('Session ID missing from cart forms, reattaching');
          await attachSessionIdToCart();
        }
      }
    }, 10000); // Check every 10 seconds
    
    // Stop watchers after 15 minutes
    setTimeout(() => {
      clearInterval(urlWatcher);
      clearInterval(sessionIdWatcher);
    }, 900000);
    
    log('Redyoos Order Webhook initialized');
  }
  
  // Wait for DOM to be fully loaded, then initialize
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeOrderCompletionWebhook);
  } else {
    initializeOrderCompletionWebhook();
  }
  
  // Also initialize after a short delay for dynamic content
  setTimeout(initializeOrderCompletionWebhook, 1000);
});
</script>

<!-- 
  INTEGRATION INSTRUCTIONS:
  
  To activate this order completion webhook integration:
  
  1. Add this section to checkout/order completion pages:
     - Go to Shopify Admin > Online Store > Themes
     - Edit the active theme
     - Add to checkout.liquid or thank_you.liquid templates
     - Or add "redyoos-checkout-webhook" to relevant sections
     
  2. Or add via theme customizer:
     - Go to checkout pages in theme customizer
     - Add section > Redyoos Order Webhook
     - Configure webhook URL if needed
     
  3. CORS SOLUTION SETUP (IMPORTANT):
     To avoid CORS errors, also include the webhook proxy section:
     - Add {% section 'redyoos-webhook-proxy' %} to your template
     - Or uncomment the line in the CORS BYPASS INTEGRATION section above
     - This provides multiple CORS-bypass methods for reliable webhook delivery
     
  4. The section will automatically:
     - Detect order completion using multiple methods
     - Extract checkout_token and cart_token from order data
     - Enhance jewelryItems in sessionStorage with tokens
     - Send enhanced payload via CORS-safe methods to webhook endpoint
     - Clear sessionStorage after successful send
     
  5. Double Payload Flow:
     - First: Shopify's orders/create webhook fires (handled by redyoos-order-attributes.liquid)
     - Second: This enhanced jewelryItems webhook fires with tokens
     
  CORS BYPASS METHODS USED:
  - Image pixel tracking (most reliable, converts POST to GET)
  - Navigator.sendBeacon API (designed for analytics)
  - Hidden form submission to iframe
  - JSONP-style script injection
  - No-CORS fetch as fallback
     
  TROUBLESHOOTING:
  - Check browser console for "[REDYOOS ORDER WEBHOOK]" logs
  - Look for "[REDYOOS WEBHOOK PROXY]" logs to verify CORS bypass is working
  - Verify jewelryItems exists in sessionStorage
  - Test webhook endpoint URL separately
  - Ensure proper page detection on order completion
  - Check that order tokens are being extracted successfully
  - If still seeing CORS errors, ensure redyoos-webhook-proxy section is included
-->